{"version":3,"file":"flicking.esm.js","sources":["../src/utils.ts","../src/consts.ts","../src/components/Panel.ts","../src/components/PanelManager.ts","../src/states/State.ts","../src/states/IdleState.ts","../src/states/HoldingState.ts","../src/states/DraggingState.ts","../src/states/AnimatingState.ts","../src/states/DisabledState.ts","../src/components/StateMachine.ts","../src/moves/MoveType.ts","../src/moves/Snap.ts","../src/moves/FreeScroll.ts","../src/components/Viewport.ts","../src/Flicking.ts"],"sourcesContent":["import { ElementLike } from \"./types\";\n\nexport function merge(target: object, ...srcs: object[]): object {\n  srcs.forEach(source => {\n    Object.keys(source).forEach(key => {\n      const value = source[key];\n      target[key] = value;\n    });\n  });\n\n  return target;\n}\n\nexport function parseElement(element: ElementLike | ElementLike[]): HTMLElement[] {\n  if (!Array.isArray(element)) {\n    element = [element];\n  }\n\n  const elements: HTMLElement[] = [];\n  element.forEach(el => {\n    if (isString(el)) {\n      const tempDiv = document.createElement(\"div\");\n      tempDiv.innerHTML = el;\n\n      elements.push(...toArray(tempDiv.children) as HTMLElement[]);\n    } else {\n      elements.push(el as HTMLElement);\n    }\n  });\n\n  return elements;\n}\n\n// Check whether browser supports transform: translate3d\n// https://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support\nexport let checkTranslateSupport = () => {\n  const transforms = {\n    webkitTransform: \"-webkit-transform\",\n    msTransform: \"-ms-transform\",\n    MozTransform: \"-moz-transform\",\n    OTransform: \"-o-transform\",\n    transform: \"transform\",\n  };\n\n  const supportedStyle = document.documentElement.style;\n  let transformName = \"\";\n  for (const prefixedTransform in transforms) {\n    if (prefixedTransform in supportedStyle) {\n      transformName = prefixedTransform;\n    }\n  }\n\n  if (!transformName) {\n    throw new Error(\"Browser doesn't support CSS3 2D Transforms.\");\n  }\n\n  const el = document.createElement(\"div\");\n\n  document.documentElement.insertBefore(el, null);\n\n  el.style[transformName] = \"translate3d(1px, 1px, 1px)\";\n  const styleVal = window.getComputedStyle(el).getPropertyValue(transforms[transformName]);\n\n  el.parentElement!.removeChild(el);\n\n  const transformInfo = {\n    name: transformName,\n    has3d: styleVal.length > 0 && styleVal !== \"none\",\n  };\n\n  checkTranslateSupport = () => transformInfo;\n\n  return transformInfo;\n};\nexport function isString(value: any): value is string {\n  return typeof value === \"string\";\n}\n// Get class list of element as string array\nexport function classList(element: HTMLElement): string[] {\n  return element.classList\n    ? toArray(element.classList)\n    : element.className.split(\" \");\n}\n\n// Add class to specified element\nexport function addClass(element: HTMLElement, className: string): void {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    if (element.className.indexOf(className) < 0) {\n      element.className = (`${element.className} ${className}`).replace(/\\s{2,}/g, \" \");\n    }\n  }\n}\n\nexport function applyCSS(element: HTMLElement, cssObj: object): void {\n  Object.keys(cssObj).forEach(property => {\n    element.style[property] = cssObj[property];\n  });\n}\n\nexport function clamp(val: number, min: number, max: number) {\n  return Math.max(Math.min(val, max), min);\n}\n\n// Min: inclusive, Max: exclusive\nexport function isBetween(val: number, min: number, max: number) {\n  return val >= min && val <= max;\n}\n\nexport interface ArrayLike<T> {\n  length: number;\n  [index: number]: T;\n}\n\nexport function toArray<T>(iterable: ArrayLike<T>): T[] {\n  return [].slice.call(iterable);\n}\n\nexport function isArray(arr: any): boolean {\n  return arr && arr.constructor === Array;\n}\n\nexport function parseArithmeticExpression(cssValue: number | string, base: number, defaultVal?: number): number {\n  // Set base / 2 to default value, if it's undefined\n  const defaultValue = defaultVal != null ? defaultVal : base / 2;\n  const cssRegex = /(?:(\\+|\\-)\\s*)?(\\d+(?:\\.\\d+)?(%|px)?)/g;\n\n  if (typeof cssValue === \"number\") {\n    return clamp(cssValue, 0, base);\n  }\n\n  let idx = 0;\n  let calculatedValue = 0;\n  let matchResult = cssRegex.exec(cssValue);\n  while (matchResult != null) {\n    let sign = matchResult[1];\n    const value = matchResult[2];\n    const unit = matchResult[3];\n\n    let parsedValue = parseFloat(value);\n\n    if (idx <= 0) {\n      sign = sign || \"+\";\n    }\n\n    // Return default value for values not in good form\n    if (!sign) {\n      return defaultValue;\n    }\n\n    if (unit === \"%\") {\n      parsedValue = (parsedValue / 100) * base;\n    }\n\n    calculatedValue += sign === \"+\"\n      ? parsedValue\n      : -parsedValue;\n\n    // Match next occurrence\n    ++idx;\n    matchResult = cssRegex.exec(cssValue);\n  }\n\n  // None-matched\n  if (idx === 0) {\n    return defaultValue;\n  }\n\n  // Clamp between 0 ~ base\n  return clamp(calculatedValue, 0, base);\n}\n\nexport function getProgress(pos: number, range: number[]) {\n  // start, anchor, end\n  // -1 , 0 , 1\n  const [min, center, max] = range;\n\n  if (pos > center && (max - center)) {\n    // 0 ~ 1\n    return (pos - center) / (max - center);\n  } else if (pos < center && (center - min)) {\n    // -1 ~ 0\n    return (pos - center) / (center - min);\n  } else if (pos !== center && max - min) {\n    return (pos - min) / (max - min);\n  }\n  return 0;\n}\n\nexport function findIndex<T>(iterable: T[], callback: (el: T) => boolean): number {\n  for (let i = 0; i < iterable.length; i += 1) {\n    const element = iterable[i];\n    if (element && callback(element)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n// return [0, 1, ...., max - 1]\nexport function counter(max: number): number[] {\n  const counterArray: number[] = [];\n  for (let i = 0; i < max; i += 1) {\n    counterArray[i] = i;\n  }\n  return counterArray;\n}\n\n// Circulate number between range [min, max]\n/*\n * \"indexed\" means min and max is not same, so if it's true \"min - 1\" should be max\n * While if it's false, \"min - 1\" should be \"max - 1\"\n * use `indexed: true` when it should be used for circulating integers like index\n * or `indexed: false` when it should be used for something like positions.\n */\nexport function circulate(value: number, min: number, max: number, indexed: boolean): number {\n  const size = indexed\n    ? max - min + 1\n    : max - min;\n  if (value < min) {\n    const offset = indexed\n      ? (min - value - 1) % size\n      : (min - value) % size;\n    value = max - offset;\n  } else if (value > max) {\n    const offset = indexed\n      ? (value - max - 1) % size\n      : (value - max) % size;\n    value = min + offset;\n  }\n\n  return value;\n}\n","import { FlickingOptions, EventType, Direction, AxesEventType, StateType, MoveTypeSnapOption, MoveTypeFreeScrollOption } from \"./types\";\nimport { checkTranslateSupport } from \"./utils\";\n\nexport const MOVE_TYPE: {\n  SNAP: \"snap\";\n  FREE_SCROLL: \"freeScroll\";\n} = {\n  SNAP: \"snap\",\n  FREE_SCROLL: \"freeScroll\",\n};\n\nexport const DEFAULT_MOVE_TYPE_OPTIONS: {\n  snap: MoveTypeSnapOption,\n  freeScroll: MoveTypeFreeScrollOption,\n} = {\n  snap: {\n    type: \"snap\",\n    count: 1,\n  },\n  freeScroll: {\n    type: \"freeScroll\",\n  },\n};\n\nexport const DEFAULT_OPTIONS: Readonly<FlickingOptions> = {\n  classPrefix: \"eg-flick\",\n  deceleration: 0.0075,\n  horizontal: true,\n  circular: false,\n  infinite: false,\n  infiniteThreshold: 0,\n  lastIndex: Infinity,\n  threshold: 40,\n  duration: 100,\n  panelEffect: x => 1 - Math.pow(1 - x, 3),\n  defaultIndex: 0,\n  inputType: [\"touch\", \"mouse\"],\n  thresholdAngle: 45,\n  bounce: 10,\n  autoResize: false,\n  adaptive: false,\n  zIndex: 2000,\n  bound: false,\n  overflow: false,\n  hanger: \"50%\",\n  anchor: \"50%\",\n  gap: 0,\n  moveType: DEFAULT_MOVE_TYPE_OPTIONS.snap,\n};\n\nexport const DEFAULT_VIEWPORT_CSS = {\n  position: \"relative\",\n  zIndex: DEFAULT_OPTIONS.zIndex,\n  width: \"100%\",\n  height: \"100%\",\n  // willChange: \"transform\",\n  overflow: \"hidden\",\n};\n\nexport const DEFAULT_CAMERA_CSS = {\n  width: \"100%\",\n  height: \"100%\",\n  willChange: \"transform\",\n};\n\nexport const DEFAULT_PANEL_CSS = {\n  position: \"absolute\",\n};\n\nexport const EVENTS: EventType = {\n  HOLD_START: \"holdStart\",\n  HOLD_END: \"holdEnd\",\n  MOVE_START: \"moveStart\",\n  MOVE: \"move\",\n  MOVE_END: \"moveEnd\",\n  CHANGE: \"change\",\n  RESTORE: \"restore\",\n  SELECT: \"select\",\n  NEED_PANEL: \"needPanel\",\n};\n\nexport const AXES_EVENTS: AxesEventType = {\n  HOLD: \"hold\",\n  CHANGE: \"change\",\n  RELEASE: \"release\",\n  ANIMATION_END: \"animationEnd\",\n  FINISH: \"finish\",\n};\n\nexport const STATE_TYPE: StateType = {\n  IDLE: 0,\n  HOLDING: 1,\n  DRAGGING: 2,\n  ANIMATING: 3,\n  DISABLED: 4,\n};\n\nexport const DIRECTION: Direction = {\n  PREV: \"PREV\",\n  NEXT: \"NEXT\",\n};\n\nexport const TRANSFORM = checkTranslateSupport();\n","import Viewport from \"./Viewport\";\nimport { OriginalStyle, FlickingPanel, ElementLike } from \"../types\";\nimport { DEFAULT_PANEL_CSS, EVENTS } from \"../consts\";\nimport { addClass, applyCSS, parseArithmeticExpression, parseElement, getProgress } from \"../utils\";\n\nclass Panel implements FlickingPanel {\n  public prevSibling: Panel | null;\n  public nextSibling: Panel | null;\n\n  private element: HTMLElement;\n  private viewport: Viewport;\n  private state: {\n    index: number;\n    position: number;\n    relativeAnchorPosition: number;\n    size: number;\n    isClone: boolean;\n    // Index of cloned panel, zero-based integer(original: -1, cloned: [0, 1, 2, ...])\n    // if cloneIndex is 0, that means it's first cloned panel of original panel\n    cloneIndex: number;\n    originalStyle: OriginalStyle;\n    clonedPanels: Panel[];\n    cachedBbox: ClientRect | null;\n  };\n  private original?: Panel;\n\n  public constructor(\n    element: HTMLElement,\n    index: number,\n    viewport: Viewport,\n  ) {\n    this.element = element;\n    this.viewport = viewport;\n    this.prevSibling = null;\n    this.nextSibling = null;\n\n    this.state = {\n      index,\n      position: 0,\n      relativeAnchorPosition: 0,\n      size: 0,\n      clonedPanels: [],\n      isClone: false,\n      cloneIndex: -1,\n      originalStyle: {\n        className: element.getAttribute(\"class\") || null,\n        style: element.getAttribute(\"style\") || null,\n      },\n      cachedBbox: null,\n    };\n\n    const options = viewport.options;\n\n    if (options.classPrefix) {\n      addClass(element, `${options.classPrefix}-panel`);\n    }\n\n    // Update size info after applying panel css\n    applyCSS(this.element, DEFAULT_PANEL_CSS);\n  }\n\n  public resize(): void {\n    const state = this.state;\n    const options = this.viewport.options;\n    const bbox = this.getBbox();\n\n    state.size = options.horizontal\n      ? bbox.width\n      : bbox.height;\n    state.relativeAnchorPosition = parseArithmeticExpression(options.anchor, state.size);\n\n    if (!state.isClone) {\n      state.clonedPanels.forEach(panel => panel.resize());\n    }\n  }\n\n  public unCacheBbox(): void {\n    this.state.cachedBbox = null;\n  }\n\n  public getProgress() {\n    const viewport = this.viewport;\n    const options = viewport.options;\n    const panelCount = viewport.panelManager.getPanelCount();\n    const scrollAreaSize = viewport.getScrollAreaSize();\n\n    const relativeIndex = (options.circular ? Math.floor(this.getPosition() / scrollAreaSize) * panelCount : 0) + this.getIndex();\n    const progress = relativeIndex - viewport.getCurrentProgress();\n\n    return progress;\n  }\n\n  public getOutsetProgress() {\n    const viewport = this.viewport;\n    const outsetRange = [\n      -this.getSize(),\n      viewport.getRelativeHangerPosition() - this.getRelativeAnchorPosition(),\n      viewport.getSize(),\n    ];\n    const relativePanelPosition = this.getPosition() - viewport.getCameraPosition();\n    const outsetProgress = getProgress(relativePanelPosition, outsetRange);\n\n    return outsetProgress;\n  }\n\n  public getVisibleRatio() {\n    const viewport = this.viewport;\n    const panelSize = this.getSize();\n    const relativePanelPosition = this.getPosition() - viewport.getCameraPosition();\n    const rightRelativePanelPosition = relativePanelPosition + panelSize;\n\n    const visibleSize = Math.min(viewport.getSize(), rightRelativePanelPosition) - Math.max(relativePanelPosition, 0);\n    const visibleRatio = visibleSize >= 0\n      ? visibleSize / panelSize\n      : 0;\n\n    return visibleRatio;\n  }\n\n  public focus(duration?: number): void {\n    const viewport = this.viewport;\n    const currentPanel = viewport.getCurrentPanel();\n    const hangerPosition = viewport.getHangerPosition();\n    const anchorPosition = this.getAnchorPosition();\n    if (hangerPosition === anchorPosition || !currentPanel) {\n      return;\n    }\n\n    const currentPosition = currentPanel.getPosition();\n    const eventType = currentPosition === this.getPosition()\n      ? \"\"\n      : EVENTS.CHANGE;\n\n    viewport.moveTo(this, viewport.findEstimatedPosition(this), eventType, null, duration);\n  }\n\n  public update(updateFunction: (element: HTMLElement) => any): void {\n    this.getIdenticalPanels()\n      .forEach(eachPanel => {\n        updateFunction(eachPanel.getElement());\n        eachPanel.unCacheBbox();\n      });\n    this.viewport.resize();\n  }\n\n  public prev(): FlickingPanel | null {\n    const viewport = this.viewport;\n    const options = viewport.options;\n    const prevSibling = this.prevSibling;\n\n    if (!prevSibling) {\n      return null;\n    }\n\n    const currentIndex = this.getIndex();\n    const currentPosition = this.getPosition();\n    const prevPanelIndex = prevSibling.getIndex();\n    const prevPanelPosition = prevSibling.getPosition();\n    const prevPanelSize = prevSibling.getSize();\n\n    const hasEmptyPanelBetween = currentIndex - prevPanelIndex > 1;\n    const notYetMinPanel = options.infinite\n      && currentIndex > 0\n      && prevPanelIndex > currentIndex;\n\n    if (hasEmptyPanelBetween || notYetMinPanel) {\n      // Empty panel exists between\n      return null;\n    }\n\n    const newPosition = currentPosition - prevPanelSize - options.gap;\n\n    let prevPanel = prevSibling;\n    if (prevPanelPosition !== newPosition) {\n      prevPanel = prevSibling.clone(prevSibling.getCloneIndex(), true);\n      prevPanel.setPosition(newPosition, true);\n    }\n\n    return prevPanel;\n  }\n\n  public next(): FlickingPanel | null {\n    const viewport = this.viewport;\n    const options = viewport.options;\n    const nextSibling = this.nextSibling;\n    const lastIndex = viewport.panelManager.getLastIndex();\n\n    if (!nextSibling) {\n      return null;\n    }\n\n    const currentIndex = this.getIndex();\n    const currentPosition = this.getPosition();\n    const nextPanelIndex = nextSibling.getIndex();\n    const nextPanelPosition = nextSibling.getPosition();\n\n    const hasEmptyPanelBetween = nextPanelIndex - currentIndex > 1;\n    const notYetMaxPanel = options.infinite\n      && currentIndex < lastIndex\n      && nextPanelIndex < currentIndex;\n\n    if (hasEmptyPanelBetween || notYetMaxPanel) {\n      return null;\n    }\n\n    const newPosition = currentPosition + this.getSize() + options.gap;\n\n    let nextPanel = nextSibling;\n    if (nextPanelPosition !== newPosition) {\n      nextPanel = nextSibling.clone(nextSibling.getCloneIndex(), true);\n      nextPanel.setPosition(newPosition, true);\n    }\n\n    return nextPanel;\n  }\n\n  public insertBefore(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n    const parsedElements = parseElement(element);\n    const firstPanel = viewport.panelManager.firstPanel()!;\n    const prevSibling = this.prevSibling;\n    // Finding correct inserting index\n    // While it should insert removing empty spaces,\n    // It also should have to be bigger than prevSibling' s index\n    const targetIndex = prevSibling && firstPanel.getIndex() !== this.getIndex()\n      ? Math.max(prevSibling.getIndex() + 1, this.getIndex() - parsedElements.length)\n      : Math.max(this.getIndex() - parsedElements.length, 0);\n\n    return viewport.insert(targetIndex, parsedElements);\n  }\n\n  public insertAfter(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    return this.viewport.insert(this.getIndex() + 1, element);\n  }\n\n  public remove(): FlickingPanel {\n    this.viewport.remove(this.getIndex());\n\n    return this;\n  }\n\n  public destroy(): void {\n    const el = this.element;\n    const originalStyle = this.state.originalStyle;\n\n    originalStyle.className\n      ? el.setAttribute(\"class\", originalStyle.className)\n      : el.removeAttribute(\"class\");\n    originalStyle.style\n      ? el.setAttribute(\"style\", originalStyle.style)\n      : el.removeAttribute(\"style\");\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public getElement(): HTMLElement {\n    return this.element;\n  }\n\n  public getAnchorPosition(): number {\n    return this.state.position + this.state.relativeAnchorPosition;\n  }\n\n  public getRelativeAnchorPosition(): number {\n    return this.state.relativeAnchorPosition;\n  }\n\n  public getIndex(): number {\n    return this.state.index;\n  }\n\n  public getPosition(): number {\n    return this.state.position;\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getBbox(): ClientRect {\n    const state = this.state;\n    if (!state.cachedBbox) {\n      state.cachedBbox = this.element.getBoundingClientRect();\n    }\n    return state.cachedBbox;\n  }\n\n  public isClone(): boolean {\n    return this.state.isClone;\n  }\n\n  public getCloneIndex(): number {\n    return this.state.cloneIndex;\n  }\n\n  public getClonedPanels(): Panel[] {\n    const state = this.state;\n\n    return state.isClone\n      ? this.original!.getClonedPanels()\n      : state.clonedPanels;\n  }\n\n  public getIdenticalPanels(): Panel[] {\n    const state = this.state;\n\n    return state.isClone\n      ? this.original!.getIdenticalPanels()\n      : [this, ...state.clonedPanels];\n  }\n\n  public getOriginalPanel(): Panel {\n    return this.state.isClone\n      ? this.original!\n      : this;\n  }\n\n  public setIndex(index: number): void {\n    const state = this.state;\n\n    state.index = index;\n    state.clonedPanels.forEach(panel => panel.state.index = index);\n  }\n\n  public setPosition(pos: number, virtual: boolean = false): this {\n    const state = this.state;\n    const options = this.viewport.options;\n    const elementStyle = this.element.style;\n\n    state.position = pos;\n    if (!virtual) {\n      options.horizontal\n        ? elementStyle.left = `${pos}px`\n        : elementStyle.top = `${pos}px`;\n    }\n\n    return this;\n  }\n\n  public clone(cloneIndex: number, virtual: boolean = false): Panel {\n    const state = this.state;\n\n    const cloneElement = virtual\n      ? this.element\n      : this.element.cloneNode(true) as HTMLElement;\n    const clonedPanel = new Panel(cloneElement, state.index, this.viewport);\n    const clonedState = clonedPanel.state;\n\n    clonedPanel.original = this;\n    clonedState.isClone = true;\n    clonedState.cloneIndex = cloneIndex;\n    // Inherit some state values\n    clonedState.size = state.size;\n    clonedState.relativeAnchorPosition = state.relativeAnchorPosition;\n    clonedState.originalStyle = state.originalStyle;\n    clonedState.cachedBbox = state.cachedBbox;\n\n    if (!virtual) {\n      state.clonedPanels.push(clonedPanel);\n    } else {\n      clonedPanel.prevSibling = this.prevSibling;\n      clonedPanel.nextSibling = this.nextSibling;\n    }\n\n    return clonedPanel;\n  }\n\n  public removeElement(): void {\n    const element = this.element;\n    element.parentNode!.removeChild(element);\n\n    // Do the same thing for clones\n    if (!this.state.isClone) {\n      this.removeClonedPanelsAfter(0);\n    }\n  }\n\n  public removeClonedPanelsAfter(start: number): void {\n    const state = this.state;\n    const removingPanels = state.clonedPanels.splice(start);\n\n    removingPanels.forEach(panel => {\n      panel.removeElement();\n    });\n  }\n}\n\nexport default Panel;\n","import Panel from \"./Panel\";\nimport { FlickingOptions } from \"../types\";\nimport { findIndex, counter } from \"../utils\";\n\nclass PanelManager {\n  private cameraElement: HTMLElement;\n  private panels: Panel[];\n  private clones: Panel[][];\n  // index range of existing panels\n  private range: {\n    min: number;\n    max: number;\n  };\n  private length: number;\n  private lastIndex: number;\n  private options: FlickingOptions;\n\n  constructor(\n    cameraElement: HTMLElement,\n    options: FlickingOptions,\n  ) {\n    this.cameraElement = cameraElement;\n    this.panels = [];\n    this.clones = [];\n    this.range = {\n      min: -1,\n      max: -1,\n    };\n    this.length = 0;\n    this.options = options;\n    this.lastIndex = options.lastIndex;\n  }\n\n  public firstPanel(): Panel | undefined {\n    return this.panels[this.range.min];\n  }\n\n  public lastPanel(): Panel | undefined {\n    return this.panels[this.range.max];\n  }\n\n  public allPanels(): ReadonlyArray<Panel> {\n    return [\n      ...this.panels,\n      ...this.clonedPanels(),\n    ];\n  }\n\n  public originalPanels(): ReadonlyArray<Panel> {\n    return this.panels;\n  }\n\n  public clonedPanels(): ReadonlyArray<Panel> {\n    return this.clones.reduce((allClones, clones) => [...allClones, ...clones], []);\n  }\n\n  public has(index: number): boolean {\n    return !!this.panels[index];\n  }\n\n  public get(index: number): Panel | undefined {\n    return this.panels[index];\n  }\n\n  public getPanelCount(): number {\n    return this.length;\n  }\n\n  public getLastIndex(): number {\n    return this.lastIndex;\n  }\n\n  public getRange(): Readonly<{ min: number, max: number }> {\n    return this.range;\n  }\n\n  public getCloneCount(): number {\n    return this.clones.length;\n  }\n\n  public setLastIndex(lastIndex: number): void {\n    this.lastIndex = lastIndex;\n\n    const firstPanel = this.firstPanel();\n    const lastPanel = this.lastPanel();\n\n    if (!firstPanel || !lastPanel) {\n      return; // no meaning of updating range & length\n    }\n\n    // Remove panels above new last index\n    const range = this.range;\n    if (lastPanel.getIndex() > lastIndex) {\n      const removingPanels = this.panels.splice(lastIndex + 1);\n      removingPanels.forEach(panel => panel.removeElement());\n      this.length -= removingPanels.length;\n\n      const firstRemovedPanel = removingPanels.filter(panel => !!panel)[0];\n      const possibleLastPanel = firstRemovedPanel.prevSibling;\n      if (possibleLastPanel) {\n        range.max = possibleLastPanel.getIndex();\n      } else {\n        range.min = -1;\n        range.max = -1;\n      }\n    }\n  }\n\n  public append(newPanels: Panel[]): void {\n    const range = this.range;\n    this.panels.push(...newPanels);\n\n    if (newPanels.length > 0) {\n      range.min = Math.max(0, range.min);\n      range.max += newPanels.length;\n      this.length += newPanels.length;\n    }\n  }\n\n  // Insert at index\n  // Returns pushed elements from index, inserting at 'empty' position doesn't push elements behind it\n  public insert(index: number, newPanels: Panel[]): number {\n    const panels = this.panels;\n    const range = this.range;\n    const cameraElement = this.cameraElement;\n    const isCircular = this.options.circular;\n    const lastIndex = this.lastIndex;\n\n    // Find first panel that index is greater than inserting index\n    const nextSibling = this.findFirstPanelFrom(index);\n\n    // if it's null, element will be inserted at last position\n    // https://developer.mozilla.org/ko/docs/Web/API/Node/insertBefore#Syntax\n    const firstPanel = this.firstPanel();\n    const siblingElement = nextSibling\n      ? nextSibling.getElement()\n      : isCircular && firstPanel\n        ? firstPanel.getClonedPanels()[0].getElement()\n        : null;\n\n    // Insert panels before sibling element\n    const fragment = document.createDocumentFragment();\n    newPanels.forEach(panel => fragment.appendChild(panel.getElement()));\n    cameraElement.insertBefore(fragment, siblingElement);\n\n    let pushedIndex = newPanels.length;\n    // Like when setting index 50 while visible panels are 0, 1, 2\n    if (index > range.max) {\n      newPanels.forEach((panel, offset) => {\n        panels[index + offset] = panel;\n      });\n    } else {\n      const panelsAfterIndex = panels.slice(index, index + newPanels.length);\n      // Find empty from beginning\n      let emptyPanelCount = findIndex(panelsAfterIndex, panel => !!panel);\n      if (emptyPanelCount < 0) {\n        // All empty\n        emptyPanelCount = panelsAfterIndex.length;\n      }\n      pushedIndex = newPanels.length - emptyPanelCount;\n\n      // Insert removing empty panels\n      panels.splice(index, emptyPanelCount, ...newPanels);\n\n      // Remove panels after last index\n      if (panels.length > lastIndex + 1) {\n        const removedPanels = panels.splice(lastIndex + 1)\n          .filter(panel => Boolean(panel));\n        removedPanels.forEach(panel => panel.removeElement());\n        this.length -= removedPanels.length;\n\n        // Find first\n        const newLastIndex = lastIndex - findIndex(this.panels.concat().reverse(), panel => !!panel);\n\n        // Can be filled with empty after newLastIndex\n        this.panels.splice(newLastIndex + 1);\n        this.range.max = newLastIndex;\n      }\n    }\n\n    // Update index of previous panels\n    if (pushedIndex > 0) {\n      panels.slice(index + newPanels.length).forEach(panel => {\n        panel.setIndex(panel.getIndex() + pushedIndex);\n      });\n    }\n\n    if (isCircular) {\n      this.addNewClones(index, newPanels, newPanels.length - pushedIndex, nextSibling);\n    }\n\n    // Update state\n    this.length += newPanels.length;\n    this.updateIndex(index);\n\n    return pushedIndex;\n  }\n\n  public replace(index: number, newPanels: Panel[]): void {\n    const panels = this.panels;\n    const range = this.range;\n    const cameraElement = this.cameraElement;\n    const isCircular = this.options.circular;\n\n    // Find first panel that index is greater than inserting index\n    const nextSibling = this.findFirstPanelFrom(index + newPanels.length);\n\n    // if it's null, element will be inserted at last position\n    // https://developer.mozilla.org/ko/docs/Web/API/Node/insertBefore#Syntax\n    const firstPanel = this.firstPanel();\n    const siblingElement = nextSibling\n      ? nextSibling.getElement()\n      : isCircular && firstPanel\n        ? firstPanel.getClonedPanels()[0].getElement()\n        : null;\n\n    // Insert panels before sibling element\n    const fragment = document.createDocumentFragment();\n    newPanels.forEach(panel => fragment.appendChild(panel.getElement()));\n    cameraElement.insertBefore(fragment, siblingElement);\n\n    if (index > range.max) {\n      // Temporarily insert null at index to use splice()\n      (panels[index] as any) = null;\n    }\n\n    const replacedPanels = panels.splice(index, newPanels.length, ...newPanels);\n    const wasNonEmptyCount = replacedPanels.filter(panel => Boolean(panel)).length;\n    replacedPanels.forEach(panel => {\n      if (panel) {\n        panel.removeElement();\n      }\n    });\n\n    // Suppose inserting [1, 2, 3] at 0 position when there were [empty, 1]\n    // So length should be increased by 3(inserting panels) - 1(non-empty panels)\n    this.length += newPanels.length - wasNonEmptyCount;\n    this.updateIndex(index);\n\n    if (isCircular) {\n      this.addNewClones(index, newPanels, newPanels.length, nextSibling);\n    }\n  }\n\n  public remove(index: number, deleteCount: number = 1): Panel[] {\n    const isCircular = this.options.circular;\n    const panels = this.panels;\n    const clones = this.clones;\n    // Delete count should be equal or larger than 0\n    deleteCount = Math.max(deleteCount, 0);\n\n    const deletedPanels = panels\n      .splice(index, deleteCount)\n      .filter(panel => !!panel);\n\n    deletedPanels.forEach(panel => {\n      panel.removeElement();\n    });\n\n    if (isCircular) {\n      clones.forEach(cloneSet => {\n        cloneSet.splice(index, deleteCount);\n      });\n    }\n\n    // Update indexes\n    panels\n      .slice(index)\n      .forEach(panel => {\n        panel.setIndex(panel.getIndex() - deleteCount);\n      });\n\n    // Check last panel is empty\n    let lastIndex = panels.length - 1;\n    if (!panels[lastIndex]) {\n      const reversedPanels = panels.concat().reverse();\n      const nonEmptyIndexFromLast = findIndex(reversedPanels, panel => !!panel);\n      lastIndex = nonEmptyIndexFromLast < 0\n        ? -1 // All empty\n        : lastIndex - nonEmptyIndexFromLast;\n\n      // Remove all empty panels from last\n      panels.splice(lastIndex + 1);\n      if (isCircular) {\n        clones.forEach(cloneSet => {\n          cloneSet.splice(lastIndex + 1);\n        });\n      }\n    }\n\n    // Update range & length\n    this.range = {\n      min: findIndex(panels, panel => !!panel),\n      max: lastIndex,\n    };\n    this.length -= deletedPanels.length;\n\n    if (this.length <= 0) {\n      // Reset clones\n      this.clones = [];\n    }\n\n    return deletedPanels;\n  }\n\n  public chainAllPanels() {\n    const allPanels = this.allPanels().filter(panel => !!panel);\n    const allPanelsCount = allPanels.length;\n\n    if (allPanelsCount <= 0) {\n      return;\n    }\n\n    allPanels.forEach((panel, idx) => {\n      const prevPanel = (idx > 0)\n        ? allPanels[idx - 1]\n        : null;\n\n      const nextPanel = (idx < allPanelsCount - 1)\n        ? allPanels[idx + 1]\n        : null;\n\n      panel.prevSibling = prevPanel;\n      panel.nextSibling = nextPanel;\n    });\n\n    if (this.options.circular) {\n      const firstPanel = allPanels[0];\n      const lastPanel = allPanels[allPanelsCount - 1];\n\n      firstPanel.prevSibling = lastPanel;\n      lastPanel.nextSibling = firstPanel;\n    }\n  }\n\n  public insertClones(cloneIndex: number, index: number, clonedPanels: Panel[], deleteCount: number = 0): void {\n    const clones = this.clones;\n    const lastIndex = this.lastIndex;\n\n    if (!clones[cloneIndex]) {\n      const newClones: Panel[] = [];\n      clonedPanels.forEach((panel, offset) => {\n        newClones[index + offset] = panel;\n      });\n\n      clones[cloneIndex] = newClones;\n    } else {\n      const insertTarget = clones[cloneIndex];\n\n      if (index >= insertTarget.length) {\n        clonedPanels.forEach((panel, offset) => {\n          insertTarget[index + offset] = panel;\n        });\n      } else {\n        insertTarget.splice(index, deleteCount, ...clonedPanels);\n        // Remove panels after last index\n        if (clonedPanels.length > lastIndex + 1) {\n          clonedPanels.splice(lastIndex + 1);\n        }\n      }\n    }\n  }\n\n  // clones are operating in set\n  public removeClonesAfter(cloneIndex: number): void {\n    const panels = this.panels;\n    panels.forEach(panel => {\n      panel.removeClonedPanelsAfter(cloneIndex);\n    });\n    this.clones.splice(cloneIndex);\n  }\n\n  // Clear both original & cloned\n  public clear(): void {\n    this.panels.forEach(panel => {\n      panel.removeElement();\n    });\n\n    this.panels = [];\n    this.clones = [];\n    this.length = 0;\n    this.range = {\n      min: -1,\n      max: -1,\n    };\n  }\n\n  public clearClone(): void {\n    this.panels.forEach(panel => {\n      panel.removeClonedPanelsAfter(0);\n    });\n    this.clones = [];\n  }\n\n  public findPanelOf(element: HTMLElement): Panel | undefined {\n    const allPanels = this.allPanels();\n    for (const panel of allPanels) {\n      if (!panel) {\n        continue;\n      }\n      const panelElement = panel.getElement();\n      if (panelElement.contains(element)) {\n        return panel;\n      }\n    }\n  }\n\n  public findFirstPanelFrom(index: number): Panel | undefined {\n    for (const panel of this.panels) {\n      if (panel && panel.getIndex() >= index) {\n        return panel;\n      }\n    }\n  }\n\n  private addNewClones(index: number, originalPanels: Panel[], deleteCount: number, nextSibling: Panel | undefined) {\n    const cameraElement = this.cameraElement;\n    const cloneCount = this.getCloneCount();\n    const lastPanel = this.lastPanel();\n    const lastPanelClones: Panel[] = lastPanel\n      ? lastPanel.getClonedPanels()\n      : [];\n    const nextSiblingClones: Panel[] = nextSibling\n      ? nextSibling.getClonedPanels()\n      : [];\n\n    for (const cloneIndex of counter(cloneCount)) {\n      const cloneNextSibling = nextSiblingClones[cloneIndex];\n      const lastPanelSibling = lastPanelClones[cloneIndex];\n\n      const cloneSiblingElement = cloneNextSibling\n        ? cloneNextSibling.getElement()\n        : lastPanelSibling\n          ? lastPanelSibling.getElement().nextElementSibling\n          : null;\n\n      const newClones = originalPanels.map(panel => {\n        const clone = panel.clone(cloneIndex);\n\n        cameraElement.insertBefore(clone.getElement(), cloneSiblingElement);\n        return clone;\n      });\n\n      this.insertClones(cloneIndex, index, newClones, deleteCount);\n    }\n  }\n\n  private updateIndex(insertingIndex: number) {\n    const panels = this.panels;\n    const range = this.range;\n\n    const newLastIndex = panels.length - 1;\n    if (newLastIndex > range.max) {\n      range.max = newLastIndex;\n    }\n    if (insertingIndex < range.min || range.min < 0) {\n      range.min = insertingIndex;\n    }\n  }\n}\n\nexport default PanelManager;\n","import Panel from \"../components/Panel\";\nimport { ValueOf, Direction, StateType, FlickingContext } from \"../types\";\n\nabstract class State {\n  public delta: number = 0;\n  public direction: ValueOf<Direction> | null = null;\n  public targetPanel: Panel | null = null;\n  public lastPosition: number = 0;\n  public abstract readonly type: ValueOf<StateType>;\n  public abstract readonly holding: boolean;\n  public abstract readonly playing: boolean;\n\n  public onEnter(prevState: State): void {\n    this.delta = prevState.delta;\n    this.direction = prevState.direction;\n    this.targetPanel = prevState.targetPanel;\n    this.lastPosition = prevState.lastPosition;\n  }\n  public onExit(nextState: State): void {\n    // DO NOTHING\n  }\n  public onHold(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onChange(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onRelease(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onAnimationEnd(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n  public onFinish(e: any, context: FlickingContext): void {\n    // DO NOTHING\n  }\n}\n\nexport default State;\n","import State from \"./State\";\nimport { EVENTS, STATE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass IdleState extends State {\n  public readonly type = STATE_TYPE.IDLE;\n  public readonly holding = false;\n  public readonly playing = false;\n\n  public onEnter() {\n    this.direction = null;\n    this.targetPanel = null;\n    this.delta = 0;\n    this.lastPosition = 0;\n  }\n\n  public onHold(e: any, { flicking, viewport, triggerEvent, transitTo }: FlickingContext): void {\n    // Shouldn't do any action until any panels on flicking area\n    if (flicking.getPanelCount() <= 0) {\n      transitTo(STATE_TYPE.DISABLED);\n      return;\n    }\n\n    this.lastPosition = viewport.getCameraPosition();\n    triggerEvent(EVENTS.HOLD_START, e, true)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.HOLDING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  // By methods call\n  public onChange(e: any, context: FlickingContext): void {\n    const { triggerEvent, transitTo } = context;\n\n    triggerEvent(EVENTS.MOVE_START, e, false)\n      .onSuccess(() => {\n        // Trigger AnimatingState's onChange, to trigger \"move\" event immediately\n        transitTo(STATE_TYPE.ANIMATING)\n          .onChange(e, context);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n}\n\nexport default IdleState;\n","import State from \"./State\";\nimport { STATE_TYPE, EVENTS, DIRECTION } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass HoldingState extends State {\n  public readonly type = STATE_TYPE.HOLDING;\n  public readonly holding = true;\n  public readonly playing = true;\n\n  private releaseEvent: any = null;\n\n  public onChange(e: any, context: FlickingContext): void {\n    const { flicking, triggerEvent, transitTo } = context;\n\n    const offset = flicking.options.horizontal\n      ? e.inputEvent.offsetX\n      : e.inputEvent.offsetY;\n    this.direction = offset < 0\n      ? DIRECTION.NEXT\n      : DIRECTION.PREV;\n\n    triggerEvent(EVENTS.MOVE_START, e, true)\n      .onSuccess(() => {\n        // Trigger DraggingState's onChange, to trigger \"move\" event immediately\n        transitTo(STATE_TYPE.DRAGGING)\n          .onChange(e, context);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onRelease(e: any, context: FlickingContext): void {\n    const { viewport, triggerEvent, transitTo } = context;\n\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    if (e.delta.flick !== 0) {\n      // Sometimes \"release\" event on axes triggered before \"change\" event\n      // Especially if user flicked panel fast in really short amount of time\n      // if delta is not zero, that means above case happened.\n\n      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END\n      // At least one move event should be included between holdStart and holdEnd\n      e.setTo({ flick: viewport.getCameraPosition() }, 0);\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    // Can't handle select event here,\n    // As \"finish\" axes event happens\n    this.releaseEvent = e;\n  }\n\n  public onFinish(e: any, { viewport, triggerEvent, transitTo }: FlickingContext): void {\n    // Should transite to IDLE state before select event\n    // As user expects hold is already finished\n    transitTo(STATE_TYPE.IDLE);\n\n    if (!this.releaseEvent) {\n      return;\n    }\n\n    // Handle release event here\n    // To prevent finish event called twice\n    const releaseEvent = this.releaseEvent;\n\n    // Static click\n    const clickedElement = releaseEvent.inputEvent.srcEvent.target;\n    const clickedPanel = viewport.panelManager.findPanelOf(clickedElement);\n    const cameraPosition = viewport.getCameraPosition();\n\n    if (clickedPanel) {\n      const clickedPanelPosition = clickedPanel.getPosition();\n      const direction = clickedPanelPosition > cameraPosition\n        ? DIRECTION.NEXT\n        : clickedPanelPosition < cameraPosition\n          ? DIRECTION.PREV\n          : null;\n\n      // Don't provide axes event, to use axes instance instead\n      triggerEvent(EVENTS.SELECT, null, true, {\n        direction, // Direction to the clicked panel\n        index: clickedPanel.getIndex(),\n        panel: clickedPanel,\n      });\n    }\n  }\n}\n\nexport default HoldingState;\n","import State from \"./State\";\nimport { STATE_TYPE, EVENTS, MOVE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass DraggingState extends State {\n  public readonly type = STATE_TYPE.DRAGGING;\n  public readonly holding = true;\n  public readonly playing = true;\n\n  public onChange(e: any, { moveCamera, transitTo }: FlickingContext): void {\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e)\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onRelease(e: any, context: FlickingContext): void {\n    const { flicking, viewport, triggerEvent, transitTo, stopCamera } = context;\n\n    const delta = this.delta;\n    const options = flicking.options;\n    const horizontal = options.horizontal;\n    const moveType = viewport.moveType;\n    const isFreeScroll = moveType.is(MOVE_TYPE.FREE_SCROLL);\n    const inputEvent = e.inputEvent;\n\n    const velocity = horizontal\n      ? inputEvent.velocityX\n      : inputEvent.velocityY;\n    const inputDelta = horizontal\n      ? inputEvent.deltaX\n      : inputEvent.deltaY;\n    const isNextDirection = Math.abs(velocity) > 1\n      ? velocity < 0\n      : Math.abs(delta) > 0\n        ? delta > 0\n        : inputDelta < 0;\n\n    const swipeDistance = Math.max(Math.abs(delta), Math.abs(inputDelta));\n    const swipeAngle = inputEvent.deltaX\n      ? Math.abs(180 * Math.atan(inputEvent.deltaY / inputEvent.deltaX) / Math.PI)\n      : 90;\n    const belowAngleThreshold = horizontal\n      ? swipeAngle <= options.thresholdAngle\n      : swipeAngle > options.thresholdAngle;\n    const overThreshold = swipeDistance >= options.threshold\n      && belowAngleThreshold;\n\n    // Update last position to cope with Axes's animating behavior\n    // Axes uses start position when animation start\n    triggerEvent(EVENTS.HOLD_END, e, true);\n\n    const targetPanel = this.targetPanel;\n    if (!overThreshold && targetPanel) {\n      // Interrupted while animating\n      const destPos = isFreeScroll\n        ? e.destPos.flick\n        : viewport.findEstimatedPosition(targetPanel);\n      viewport.moveTo(targetPanel, destPos, \"\", e);\n      transitTo(STATE_TYPE.ANIMATING);\n      return;\n    }\n\n    const currentPanel = viewport.getCurrentPanel();\n    const nearestPanel = viewport.getNearestPanel();\n\n    if (!currentPanel || !nearestPanel) {\n      // There're no panels\n      e.stop();\n      transitTo(STATE_TYPE.IDLE);\n      return;\n    }\n\n    const moveTypeContext = {\n      viewport,\n      axesEvent: e,\n      swipeDistance,\n      isNextDirection,\n    };\n\n    const destInfo = overThreshold\n      ? moveType.findTargetPanel(moveTypeContext)\n      : moveType.findRestorePanel(moveTypeContext);\n\n    viewport.moveTo(\n      destInfo.panel,\n      destInfo.destPos,\n      destInfo.eventType,\n      e,\n      destInfo.duration,\n    ).onSuccess(() => {\n      transitTo(STATE_TYPE.ANIMATING);\n    }).onStopped(() => {\n      transitTo(STATE_TYPE.DISABLED);\n      stopCamera(e);\n    });\n  }\n}\n\nexport default DraggingState;\n","import State from \"./State\";\nimport { STATE_TYPE, EVENTS } from \"../consts\";\nimport { FlickingContext } from \"../types\";\nimport { circulate } from \"../utils\";\n\nclass AnimatingState extends State {\n  public readonly type = STATE_TYPE.ANIMATING;\n  public readonly holding = false;\n  public readonly playing = true;\n\n  public onHold(e: any, { viewport, triggerEvent, transitTo }: FlickingContext): void {\n    const options = viewport.options;\n    const scrollArea = viewport.getScrollArea();\n    const scrollAreaSize = viewport.getScrollAreaSize();\n    const loopCount = Math.floor((this.lastPosition + this.delta - scrollArea.prev) / scrollAreaSize);\n\n    const targetPanel = this.targetPanel;\n    if (options.circular && loopCount !== 0 && targetPanel) {\n      const cloneCount = viewport.panelManager.getCloneCount();\n      const originalTargetPosition = targetPanel.getPosition();\n\n      // cloneIndex is from -1 to cloneCount - 1\n      const newCloneIndex = circulate(targetPanel.getCloneIndex() - loopCount, -1, cloneCount - 1, true);\n      const newTargetPosition = originalTargetPosition - loopCount * scrollAreaSize;\n      const newTargetPanel = targetPanel.getIdenticalPanels()[newCloneIndex + 1].clone(newCloneIndex, true);\n\n      // Set new target panel considering looped count\n      newTargetPanel.setPosition(newTargetPosition, true);\n      this.targetPanel = newTargetPanel;\n    }\n\n    // Reset last position and delta\n    this.delta = 0;\n    this.lastPosition = viewport.getCameraPosition();\n\n    // Update current panel as current nearest panel\n    viewport.setCurrentPanel(viewport.getNearestPanel()!);\n    triggerEvent(EVENTS.HOLD_START, e, true)\n      .onSuccess(() => {\n        transitTo(STATE_TYPE.DRAGGING);\n      })\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onChange(e: any, { moveCamera, transitTo }: FlickingContext): void {\n    if (!e.delta.flick) {\n      return;\n    }\n\n    moveCamera(e)\n      .onStopped(() => {\n        transitTo(STATE_TYPE.DISABLED);\n      });\n  }\n\n  public onFinish(e: any, { flicking, viewport, triggerEvent, transitTo }: FlickingContext) {\n    const isTrusted = e && e.isTrusted;\n\n    viewport.options.bound\n      ? viewport.setCurrentPanel(this.targetPanel!)\n      : viewport.setCurrentPanel(viewport.getNearestPanel()!);\n    transitTo(STATE_TYPE.IDLE);\n    triggerEvent(EVENTS.MOVE_END, e, isTrusted, {\n      direction: this.direction,\n    });\n\n    if (flicking.options.adaptive) {\n      viewport.updateAdaptiveSize();\n    }\n  }\n}\n\nexport default AnimatingState;\n","import State from \"./State\";\nimport { STATE_TYPE } from \"../consts\";\nimport { FlickingContext } from \"../types\";\n\nclass DisabledState extends State {\n  public readonly type = STATE_TYPE.DISABLED;\n  public readonly holding = false;\n  public readonly playing = true;\n\n  public onAnimationEnd(e: any, { transitTo }: FlickingContext): void {\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onChange(e: any, { viewport, transitTo }: FlickingContext): void {\n    // Can stop Axes's change event\n    e.stop();\n\n    // Should update axes position as it's already changed at this moment\n    viewport.updateAxesPosition(viewport.getCameraPosition());\n    transitTo(STATE_TYPE.IDLE);\n  }\n\n  public onRelease(e: any, { transitTo }: FlickingContext): void {\n    // This is needed when stopped hold start event\n    if (e.delta.flick === 0) {\n      transitTo(STATE_TYPE.IDLE);\n    }\n  }\n}\n\nexport default DisabledState;\n","import State from \"../states/State\";\nimport { AxesEventType, ValueOf, FlickingContext, StateType } from \"../types\";\nimport { AXES_EVENTS, STATE_TYPE } from \"../consts\";\nimport IdleState from \"../states/IdleState\";\nimport HoldingState from \"../states/HoldingState\";\nimport DraggingState from \"../states/DraggingState\";\nimport AnimatingState from \"../states/AnimatingState\";\nimport DisabledState from \"../states/DisabledState\";\n\nclass StateMachine {\n  private state: State = new IdleState();\n\n  public fire(eventType: ValueOf<AxesEventType>, e: any, context: FlickingContext) {\n    const currentState = this.state;\n    switch (eventType) {\n      case AXES_EVENTS.HOLD:\n        currentState.onHold(e, context);\n        break;\n      case AXES_EVENTS.CHANGE:\n        currentState.onChange(e, context);\n        break;\n      case AXES_EVENTS.RELEASE:\n        currentState.onRelease(e, context);\n        break;\n      case AXES_EVENTS.ANIMATION_END:\n        currentState.onAnimationEnd(e, context);\n        break;\n      case AXES_EVENTS.FINISH:\n        currentState.onFinish(e, context);\n        break;\n    }\n  }\n\n  public getState(): State {\n    return this.state;\n  }\n\n  public transitTo = (nextStateType: ValueOf<StateType>): State => {\n    const currentState = this.state;\n\n    if (currentState.type !== nextStateType) {\n      let nextState: State;\n\n      switch (nextStateType) {\n        case STATE_TYPE.IDLE:\n          nextState = new IdleState();\n          break;\n        case STATE_TYPE.HOLDING:\n          nextState = new HoldingState();\n          break;\n        case STATE_TYPE.DRAGGING:\n          nextState = new DraggingState();\n          break;\n        case STATE_TYPE.ANIMATING:\n          nextState = new AnimatingState();\n          break;\n        case STATE_TYPE.DISABLED:\n          nextState = new DisabledState();\n          break;\n      }\n\n      currentState.onExit(nextState!);\n      nextState!.onEnter(currentState);\n\n      this.state = nextState!;\n    }\n    return this.state;\n  }\n}\n\nexport default StateMachine;\n","import { MoveTypeStringOption, MoveTypeContext, DestinationInfo } from \"../types\";\nimport Panel from \"../components/Panel\";\nimport { EVENTS } from \"../consts\";\n\nabstract class MoveType {\n  protected readonly abstract type: string;\n\n  public abstract findTargetPanel(ctx: MoveTypeContext): DestinationInfo;\n\n  public is(type: MoveTypeStringOption): boolean {\n    return type === this.type;\n  }\n\n  public findRestorePanel(ctx: MoveTypeContext): DestinationInfo {\n    const viewport = ctx.viewport;\n    const options = viewport.options;\n\n    const panel = options.circular\n      ? this.findRestorePanelInCircularMode(ctx)\n      : viewport.getCurrentPanel()!;\n\n    return {\n      panel,\n      destPos: viewport.findEstimatedPosition(panel),\n      duration: options.duration,\n      eventType: EVENTS.RESTORE,\n    };\n  }\n\n  // Calculate minimum distance to \"change\" panel\n  protected calcBrinkOfChange(ctx: MoveTypeContext): number {\n    const { viewport, isNextDirection } = ctx;\n\n    const options = viewport.options;\n    const currentPanel = viewport.getCurrentPanel()!;\n    const halfGap = options.gap / 2;\n\n    const relativeAnchorPosition = currentPanel.getRelativeAnchorPosition();\n\n    // Minimum distance needed to decide prev/next panel as nearest\n    /*\n     * |  Prev  |     Next     |\n     * |--------|--------------|\n     * [][      |<-Anchor    ][] <- Panel + Half-Gap\n     */\n    let minimumDistanceToChange = isNextDirection\n      ? currentPanel.getSize() - relativeAnchorPosition + halfGap\n      : relativeAnchorPosition + halfGap;\n\n    minimumDistanceToChange = Math.max(minimumDistanceToChange, options.threshold);\n\n    return minimumDistanceToChange;\n  }\n\n  private findRestorePanelInCircularMode(ctx: MoveTypeContext): Panel {\n    const viewport = ctx.viewport;\n    const originalPanel = viewport.getCurrentPanel()!.getOriginalPanel();\n    const hangerPosition = viewport.getHangerPosition();\n\n    const firstClonedPanel = originalPanel.getIdenticalPanels()[1];\n    const lapped = Math.abs(originalPanel.getAnchorPosition() - hangerPosition)\n      > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition);\n\n    return (!ctx.isNextDirection && lapped)\n      ? firstClonedPanel\n      : originalPanel;\n  }\n}\n\nexport default MoveType;\n","import MoveType from \"./MoveType\";\nimport { MOVE_TYPE, EVENTS } from \"../consts\";\nimport { MoveTypeContext, DestinationInfo } from \"../types\";\nimport { clamp } from \"../utils\";\n\nclass Snap extends MoveType {\n  protected readonly type: string = MOVE_TYPE.SNAP;\n  protected count: number;\n\n  constructor(count: number) {\n    super();\n    this.count = count;\n  }\n\n  public findTargetPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { viewport, axesEvent, swipeDistance } = ctx;\n    const snapCount = this.count;\n    const eventDelta = Math.abs(axesEvent.delta.flick);\n    const currentPanel = viewport.getCurrentPanel()!;\n    const nearestPanel = viewport.getNearestPanel()!;\n    const minimumDistanceToChange = this.calcBrinkOfChange(ctx);\n\n    // This can happen when bounce is 0\n    const shouldMoveWhenBounceIs0 = viewport.canSetBoundMode()\n      && (nearestPanel.getIndex() === currentPanel.getIndex());\n    const shouldMoveToAdjacent = !viewport.isOutOfBound()\n      && (swipeDistance <= minimumDistanceToChange || shouldMoveWhenBounceIs0);\n\n    if (snapCount > 1 && eventDelta > minimumDistanceToChange) {\n      return this.findSnappedPanel(ctx);\n    } else if (shouldMoveToAdjacent) {\n      return this.findAdjacentPanel(ctx);\n    } else {\n      return {\n        panel: nearestPanel,\n        duration: viewport.options.duration,\n        destPos: viewport.findEstimatedPosition(nearestPanel),\n        eventType: swipeDistance <= minimumDistanceToChange\n          ? EVENTS.RESTORE\n          : EVENTS.CHANGE,\n      };\n    }\n  }\n\n  protected findSnappedPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { axesEvent, viewport, isNextDirection } = ctx;\n\n    const snapCount = this.count;\n    const options = viewport.options;\n    const scrollAreaSize = viewport.getScrollAreaSize();\n    const halfGap = options.gap / 2;\n    const estimatedHangerPos = axesEvent.destPos.flick + viewport.getRelativeHangerPosition();\n    let panelToMove = viewport.getNearestPanel()!;\n    let cycleIndex = panelToMove.getCloneIndex() + 1; // 0(original) or 1(clone)\n    let passedPanelCount = 0;\n\n    while (passedPanelCount < snapCount) {\n      const siblingPanel = isNextDirection\n        ? panelToMove.nextSibling\n        : panelToMove.prevSibling;\n      if (!siblingPanel) {\n        break;\n      }\n\n      const panelIndex = panelToMove.getIndex();\n      const siblingIndex = siblingPanel.getIndex();\n      if ((isNextDirection && siblingIndex <= panelIndex)\n        || (!isNextDirection && siblingIndex >= panelIndex)\n      ) {\n        cycleIndex = isNextDirection\n          ? cycleIndex + 1\n          : cycleIndex - 1;\n      }\n      panelToMove = siblingPanel;\n      passedPanelCount += 1;\n\n      // Since panlToMove holds also cloned panels, we should use original panel's position\n      const originalPanel = panelToMove.getOriginalPanel();\n      const panelPosition = originalPanel.getPosition() + cycleIndex * scrollAreaSize;\n      const panelSize = originalPanel.getSize();\n\n      const panelNextPosition = panelPosition + panelSize + halfGap;\n      const panelPrevPosition = panelPosition - halfGap;\n\n      // Current panelToMove contains destPos\n      if (\n        (isNextDirection && panelNextPosition > estimatedHangerPos)\n        || (!isNextDirection && panelPrevPosition < estimatedHangerPos)\n      ) {\n        break;\n      }\n    }\n\n    const originalPosition = panelToMove.getOriginalPanel().getPosition();\n\n    panelToMove = panelToMove.clone(panelToMove.getCloneIndex(), true);\n    panelToMove.setPosition(originalPosition + cycleIndex * scrollAreaSize, true);\n\n    const defaultDuration = viewport.options.duration;\n    const duration = clamp(axesEvent.duration, defaultDuration, defaultDuration * passedPanelCount);\n\n    return {\n      panel: panelToMove,\n      destPos: viewport.findEstimatedPosition(panelToMove),\n      duration,\n      eventType: passedPanelCount > 0\n        ? EVENTS.CHANGE\n        : EVENTS.RESTORE,\n    };\n  }\n\n  private findAdjacentPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { viewport, isNextDirection } = ctx;\n\n    const options = viewport.options;\n    const currentIndex = viewport.getCurrentIndex();\n    const currentPanel = viewport.panelManager.get(currentIndex)!;\n    const hangerPosition = viewport.getHangerPosition();\n\n    const firstClonedPanel = currentPanel.getIdenticalPanels()[1];\n    const lapped = options.circular\n      && (Math.abs(currentPanel.getAnchorPosition() - hangerPosition)\n        > Math.abs(firstClonedPanel.getAnchorPosition() - hangerPosition));\n\n    // If lapped in circular mode, use first cloned panel as base panel\n    const basePanel = lapped\n      ? firstClonedPanel\n      : currentPanel;\n    const basePosition = basePanel.getPosition();\n\n    const adjacentPanel = isNextDirection\n      ? basePanel.nextSibling\n      : basePanel.prevSibling;\n\n    const eventType = adjacentPanel\n      ? EVENTS.CHANGE\n      : EVENTS.RESTORE;\n    const panelToMove = adjacentPanel\n      ? adjacentPanel\n      : basePanel;\n    const targetRelativeAnchorPosition = panelToMove.getRelativeAnchorPosition();\n\n    const estimatedPanelPosition = options.circular\n      ? isNextDirection\n        ? basePosition + basePanel.getSize() + targetRelativeAnchorPosition + options.gap\n        : basePosition - (panelToMove.getSize() - targetRelativeAnchorPosition) - options.gap\n      : panelToMove.getAnchorPosition();\n    const estimatedPosition = estimatedPanelPosition - viewport.getRelativeHangerPosition();\n\n    return {\n      panel: panelToMove,\n      destPos: estimatedPosition,\n      duration: options.duration,\n      eventType,\n    };\n  }\n}\n\nexport default Snap;\n","import Snap from \"./Snap\";\nimport { MOVE_TYPE, EVENTS } from \"../consts\";\nimport { MoveTypeContext, DestinationInfo } from \"../types\";\nimport { circulate } from \"../utils\";\n\nclass FreeScroll extends Snap {\n  protected readonly type: string = MOVE_TYPE.FREE_SCROLL;\n\n  constructor() {\n    // Set snap count to Infinity\n    super(Infinity);\n  }\n\n  public findTargetPanel(ctx: MoveTypeContext): DestinationInfo {\n    const { axesEvent, viewport, swipeDistance } = ctx;\n    const destPos = axesEvent.destPos.flick;\n    const minimumDistanceToChange = this.calcBrinkOfChange(ctx);\n\n    const eventDelta = Math.abs(axesEvent.delta.flick);\n    if (eventDelta > minimumDistanceToChange) {\n      const destInfo = super.findSnappedPanel(ctx);\n      destInfo.destPos = destPos;\n      destInfo.eventType = destInfo.eventType === EVENTS.RESTORE\n        ? \"\"\n        : EVENTS.CHANGE;\n\n      return destInfo;\n    } else {\n      const scrollArea = viewport.getScrollArea();\n      const estimatedPosition = circulate(destPos, scrollArea.prev, scrollArea.next, false)\n        + viewport.getRelativeHangerPosition();\n\n      return {\n        panel: viewport.findNearestPanelAt(estimatedPosition)!,\n        destPos,\n        duration: viewport.options.duration,\n        eventType: swipeDistance > minimumDistanceToChange\n          ? EVENTS.CHANGE\n          : \"\",\n      };\n    }\n  }\n\n  public findRestorePanel(ctx: MoveTypeContext): DestinationInfo {\n    return this.findTargetPanel(ctx);\n  }\n\n  protected calcBrinkOfChange(ctx: MoveTypeContext): number {\n    const { viewport, isNextDirection } = ctx;\n\n    const options = viewport.options;\n    const currentPanel = viewport.getCurrentPanel()!;\n    const halfGap = options.gap / 2;\n\n    const lastPosition = viewport.stateMachine.getState().lastPosition;\n    const currentPanelPosition = currentPanel.getPosition();\n\n    // As camera can stop anywhere in free scroll mode,\n    // minimumDistanceToChange should be calculated differently.\n    // Ref #191(https://github.com/naver/egjs-flicking/issues/191)\n    const lastHangerPosition = lastPosition + viewport.getRelativeHangerPosition();\n\n    let minimumDistanceToChange = isNextDirection\n      ? currentPanelPosition + currentPanel.getSize() - lastHangerPosition + halfGap\n      : lastHangerPosition - currentPanelPosition + halfGap;\n\n    minimumDistanceToChange = Math.max(minimumDistanceToChange, options.threshold);\n\n    return minimumDistanceToChange;\n  }\n}\n\nexport default FreeScroll;\n","import Axes, { PanInput } from \"@egjs/axes\";\n\nimport Flicking from \"../Flicking\";\nimport Panel from \"./Panel\";\nimport PanelManager from \"./PanelManager\";\nimport StateMachine from \"./StateMachine\";\nimport MoveType from \"../moves/MoveType\";\nimport { FlickingOptions, FlickingPanel, FlickingStatus, ElementLike, EventType, TriggerCallback, NeedPanelEvent, FlickingEvent, MoveTypeObjectOption } from \"../types\";\nimport { DEFAULT_VIEWPORT_CSS, DEFAULT_CAMERA_CSS, TRANSFORM, DEFAULT_OPTIONS, EVENTS, DIRECTION, STATE_TYPE, MOVE_TYPE } from \"../consts\";\nimport { clamp, applyCSS, toArray, parseArithmeticExpression, isBetween, isArray, parseElement } from \"../utils\";\nimport Snap from \"../moves/Snap\";\nimport FreeScroll from \"../moves/FreeScroll\";\n\nexport default class Viewport {\n  public options: FlickingOptions;\n  public stateMachine: StateMachine;\n  public panelManager: PanelManager;\n  public moveType: MoveType;\n\n  private flicking: Flicking;\n  private axes: Axes;\n  private panInput: PanInput;\n\n  private viewportElement: HTMLElement;\n  private cameraElement: HTMLElement;\n\n  private triggerEvent: Flicking[\"triggerEvent\"];\n  private axesHandlers: {[key: string]: any};\n\n  private currentPanel: Panel | undefined;\n  private nearestPanel: Panel | undefined;\n\n  private state: {\n    size: number;\n    position: number;\n    relativeHangerPosition: number;\n    scrollArea: {\n      prev: number;\n      next: number;\n    };\n    translate: {\n      name: string,\n      has3d: boolean,\n    };\n    infiniteThreshold: number;\n    checkedIndexes: Array<[number, number]>;\n  };\n\n  constructor(\n    flicking: Flicking,\n    viewportElement: HTMLElement,\n    cameraElement: HTMLElement,\n    options: FlickingOptions,\n    triggerEvent: Flicking[\"triggerEvent\"],\n  ) {\n    this.flicking = flicking;\n    this.viewportElement = viewportElement;\n    this.cameraElement = cameraElement;\n    this.triggerEvent = triggerEvent;\n\n    this.state = {\n      size: 0,\n      position: 0,\n      relativeHangerPosition: 0,\n      scrollArea: {\n        prev: 0,\n        next: 0,\n      },\n      translate: TRANSFORM,\n      infiniteThreshold: 0,\n      checkedIndexes: [],\n    };\n    this.options = options;\n    this.stateMachine = new StateMachine();\n    this.panelManager = new PanelManager(cameraElement, options);\n\n    this.build();\n  }\n\n  public moveTo(\n    panel: Panel,\n    destPos: number,\n    eventType: EventType[\"CHANGE\"] | EventType[\"RESTORE\"] | \"\",\n    axesEvent: any,\n    duration: number = this.options.duration,\n  ): TriggerCallback {\n    const state = this.state;\n    const currentState = this.stateMachine.getState();\n    const currentPosition = state.position;\n\n    const isTrusted = axesEvent\n      ? axesEvent.isTrusted\n      : false;\n    const direction = destPos === currentPosition\n      ? null\n      : destPos > currentPosition\n        ? DIRECTION.NEXT\n        : DIRECTION.PREV;\n\n    let eventResult: TriggerCallback;\n    if (eventType === EVENTS.CHANGE) {\n      eventResult = this.triggerEvent(EVENTS.CHANGE, axesEvent, isTrusted, {\n        index: panel.getIndex(),\n        panel,\n        direction,\n      });\n    } else if (eventType === EVENTS.RESTORE) {\n      eventResult = this.triggerEvent(EVENTS.RESTORE, axesEvent, isTrusted);\n    } else {\n      eventResult = {\n        onSuccess(callback: () => void): TriggerCallback {\n          callback();\n          return this;\n        },\n        onStopped(): TriggerCallback {\n          return this;\n        },\n      };\n    }\n\n    eventResult.onSuccess(() => {\n      currentState.delta = 0;\n      currentState.lastPosition = this.getCameraPosition();\n      currentState.targetPanel = panel;\n      currentState.direction = destPos === currentPosition\n        ? null\n        : destPos > currentPosition\n            ? DIRECTION.NEXT\n            : DIRECTION.PREV;\n\n      if (destPos === currentPosition) {\n        // no move\n        this.nearestPanel = panel;\n        this.currentPanel = panel;\n      }\n\n      if (axesEvent && axesEvent.setTo) {\n        // freeScroll only occurs in release events\n        axesEvent.setTo({ flick: destPos }, duration);\n      } else {\n        this.axes.setTo({ flick: destPos }, duration);\n      }\n    });\n\n    return eventResult;\n  }\n\n  public moveCamera(pos: number, axesEvent?: any): void {\n    const state = this.state;\n    const options = this.options;\n    const transform = state.translate.name;\n\n    // Update position & nearestPanel\n    state.position = pos;\n    this.nearestPanel = this.findNearestPanel();\n\n    const nearestPanel = this.nearestPanel;\n    const originalNearestPosition = nearestPanel\n      ? nearestPanel.getPosition()\n      : 0;\n\n    this.checkNeedPanel(axesEvent);\n\n    // Possibly modified after need panel, if it's looped\n    const modifiedNearestPosition = nearestPanel\n      ? nearestPanel.getPosition()\n      : 0;\n\n    pos += (modifiedNearestPosition - originalNearestPosition);\n    state.position = pos;\n\n    const moveVector = options.horizontal\n      ? [-pos, 0] : [0, -pos];\n    const moveCoord = moveVector.map(coord => `${Math.round(coord)}px`).join(\", \");\n\n    this.cameraElement.style[transform] = state.translate.has3d\n      ? `translate3d(${moveCoord}, 0px)`\n      : `translate(${moveCoord})`;\n  }\n\n  public stopCamera = (axesEvent: any): void => {\n    if (axesEvent && axesEvent.setTo) {\n      axesEvent.setTo({ flick: this.state.position }, 0);\n    }\n\n    this.stateMachine.transitTo(STATE_TYPE.IDLE);\n  }\n\n  public resize(): void {\n    const panelManager = this.panelManager;\n\n    this.updateSize();\n    this.updateOriginalPanelPositions();\n    this.updateAdaptiveSize();\n    this.updateScrollArea();\n\n    // Clone panels in circular mode\n    if (this.options.circular && panelManager.getPanelCount() > 0) {\n      this.clonePanels();\n      this.updateClonedPanelPositions();\n    }\n\n    panelManager.chainAllPanels();\n    this.updateCameraPosition();\n  }\n  // Find nearest anchor from current hanger position\n  public findNearestPanel(): Panel | undefined {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const hangerPosition = this.getHangerPosition();\n\n    if (this.isOutOfBound()) {\n      const position = state.position;\n\n      return position <= state.scrollArea.prev\n        ? panelManager.firstPanel()\n        : panelManager.lastPanel();\n    }\n\n    return this.findNearestPanelAt(hangerPosition);\n  }\n\n  public findNearestPanelAt(position: number): Panel | undefined {\n    const panelManager = this.panelManager;\n\n    const allPanels = panelManager.allPanels();\n    let minimumDistance = Infinity;\n    let nearestPanel: Panel | undefined;\n\n    for (const panel of allPanels) {\n      if (!panel) {\n        continue;\n      }\n      const prevPosition = panel.getPosition();\n      const nextPosition = prevPosition + panel.getSize();\n\n      // Use shortest distance from panel's range\n      const distance = isBetween(position, prevPosition, nextPosition)\n        ? 0\n        : Math.min(\n          Math.abs(prevPosition - position),\n          Math.abs(nextPosition - position),\n        );\n\n      if (distance > minimumDistance) {\n        break;\n      } else if (distance === minimumDistance) {\n        const minimumAnchorDistance = Math.abs(position - nearestPanel!.getAnchorPosition());\n        const anchorDistance = Math.abs(position - panel.getAnchorPosition());\n\n        if (anchorDistance > minimumAnchorDistance) {\n          break;\n        }\n      }\n\n      minimumDistance = distance;\n      nearestPanel = panel;\n    }\n\n    return nearestPanel;\n  }\n\n  public findNearestIdenticalPanel(panel: Panel): Panel {\n    let nearest = panel;\n    let shortestDistance = Infinity;\n    const hangerPosition = this.getHangerPosition();\n\n    const identicals = panel.getIdenticalPanels();\n    identicals.forEach(identical => {\n      const anchorPosition = identical.getAnchorPosition();\n      const distance = Math.abs(anchorPosition - hangerPosition);\n\n      if (distance < shortestDistance) {\n        nearest = identical;\n        shortestDistance = distance;\n      }\n    });\n\n    return nearest;\n  }\n\n  // Find shortest camera position that distance is minimum\n  public findShortestPositionToPanel(panel: Panel): number {\n    const state = this.state;\n    const options = this.options;\n    const anchorPosition = panel.getAnchorPosition();\n    const hangerPosition = this.getHangerPosition();\n    const distance = Math.abs(hangerPosition - anchorPosition);\n    const scrollAreaSize = state.scrollArea.next - state.scrollArea.prev;\n\n    if (!options.circular) {\n      const position = anchorPosition - state.relativeHangerPosition;\n      return this.canSetBoundMode()\n        ? clamp(position, state.scrollArea.prev, state.scrollArea.next)\n        : position;\n    } else {\n      // If going out of viewport border is more efficient way of moving, choose that position\n      return distance <= scrollAreaSize - distance\n        ? anchorPosition - state.relativeHangerPosition\n        : anchorPosition > hangerPosition\n          // PREV TO NEXT\n          ? anchorPosition - state.relativeHangerPosition - scrollAreaSize\n          // NEXT TO PREV\n          : anchorPosition - state.relativeHangerPosition + scrollAreaSize;\n    }\n  }\n\n  public findEstimatedPosition(panel: Panel): number {\n    const scrollArea = this.getScrollArea();\n\n    let estimatedPosition = panel.getAnchorPosition() - this.getRelativeHangerPosition();\n    estimatedPosition = this.canSetBoundMode()\n      ? clamp(estimatedPosition, scrollArea.prev, scrollArea.next)\n      : estimatedPosition;\n\n    return estimatedPosition;\n  }\n\n  public enable(): void {\n    this.panInput.enable();\n  }\n\n  public disable(): void {\n    this.panInput.disable();\n  }\n\n  public insert(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const lastIndex = this.panelManager.getLastIndex();\n\n    // Index should not below 0\n    if (index < 0 || index > lastIndex) {\n      return [];\n    }\n\n    const state = this.state;\n    const parsedElements = parseElement(element);\n\n    const panels = parsedElements\n      .map((el, idx) => new Panel(el, index + idx, this))\n      .slice(0, lastIndex - index + 1);\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    const pushedIndex = this.panelManager.insert(index, panels);\n\n    if (!this.currentPanel) {\n      this.currentPanel = panels[0];\n    }\n\n    // Update checked indexes in infinite mode\n    state.checkedIndexes.forEach((indexes, idx) => {\n      const [min, max] = indexes;\n      // Can fill part of indexes in range\n      if (isBetween(index, min, max)) {\n        // Remove checked index from list\n        state.checkedIndexes.splice(idx, 1);\n      } else if (index < min) {\n        // Push checked index\n        state.checkedIndexes.splice(idx, 1, [min + pushedIndex, max + pushedIndex]);\n      }\n    });\n\n    this.resize();\n\n    return panels;\n  }\n\n  public replace(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const panelManager = this.panelManager;\n    const lastIndex = panelManager.getLastIndex();\n\n    // Index should not below 0\n    if (index < 0 || index > lastIndex) {\n      return [];\n    }\n\n    const state = this.state;\n    const parsedElements = parseElement(element);\n    const panels = parsedElements\n      .map((el, idx) => new Panel(el, index + idx, this))\n      .slice(0, lastIndex - index + 1);\n\n    if (panels.length <= 0) {\n      return [];\n    }\n\n    panelManager.replace(index, panels);\n\n    const currentPanel = this.currentPanel;\n    const wasEmpty = !currentPanel;\n    if (wasEmpty) {\n      this.currentPanel = panels[0];\n    } else if (isBetween(currentPanel!.getIndex(), index, index + panels.length - 1)) {\n      // Current panel is replaced\n      this.currentPanel = panelManager.get(currentPanel!.getIndex());\n    }\n\n    // Update checked indexes in infinite mode\n    state.checkedIndexes.forEach((indexes, idx) => {\n      const [min, max] = indexes;\n      // Can fill part of indexes in range\n      if (index <= max && index + panels.length > min) {\n        // Remove checked index from list\n        state.checkedIndexes.splice(idx, 1);\n      }\n    });\n\n    this.resize();\n\n    const isFreeScroll = (this.options.moveType as MoveTypeObjectOption).type === \"freeScroll\";\n    if (isFreeScroll && wasEmpty) {\n      this.moveTo(this.currentPanel!, this.findEstimatedPosition(this.currentPanel!), \"\", null, 0);\n    }\n\n    return panels;\n  }\n\n  public remove(index: number, deleteCount: number = 1): FlickingPanel[] {\n    // Index should not below 0\n    index = Math.max(index, 0);\n\n    const panelManager = this.panelManager;\n    const currentIndex = this.getCurrentIndex();\n\n    const removedPanels = panelManager.remove(index, deleteCount);\n    if (isBetween(currentIndex, index, index + deleteCount - 1)) {\n      // Current panel is removed\n      // Use panel at removing index - 1 as new current panel if it exists\n      const newCurrentIndex = Math.max(index - 1, panelManager.getRange().min);\n      this.currentPanel = panelManager.get(newCurrentIndex);\n    }\n    this.resize();\n\n    return removedPanels;\n  }\n\n  public updateAdaptiveSize(): void {\n    const options = this.options;\n    const horizontal = options.horizontal;\n    const currentPanel = this.getCurrentPanel();\n\n    if (!currentPanel) {\n      return;\n    }\n\n    let sizeToApply: number;\n    if (options.adaptive) {\n      const panelBbox = currentPanel.getBbox();\n\n      sizeToApply = horizontal ? panelBbox.height : panelBbox.width;\n    } else {\n      // Find minimum height of panels to maximum panel size\n      const maximumPanelSize = this.panelManager.originalPanels().reduce((maximum, panel) => {\n        const panelBbox = panel.getBbox();\n        return Math.max(maximum, horizontal ? panelBbox.height : panelBbox.width);\n      }, 0);\n\n      sizeToApply = maximumPanelSize;\n    }\n\n    const viewportStyle = this.viewportElement.style;\n    if (horizontal) {\n      viewportStyle.height = `${sizeToApply}px`;\n      viewportStyle.minHeight = \"100%\";\n      viewportStyle.width = \"100%\";\n    } else {\n      viewportStyle.width = `${sizeToApply}px`;\n      viewportStyle.minWidth = \"100%\";\n      viewportStyle.height = \"100%\";\n    }\n  }\n\n  public destroy(): void {\n    const viewportElement = this.viewportElement;\n    const wrapper = viewportElement.parentElement;\n\n    wrapper!.removeChild(viewportElement);\n\n    this.axes.destroy();\n    this.panInput.destroy();\n\n    this.panelManager.originalPanels().forEach(panel => {\n      wrapper!.appendChild(panel.getElement());\n      panel.destroy();\n    });\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  public restore(status: FlickingStatus): void {\n    const panels = status.panels;\n    const defaultIndex = this.options.defaultIndex;\n    const cameraElement = this.cameraElement;\n    const panelManager = this.panelManager;\n\n    // Restore index\n    panelManager.clear();\n    cameraElement.innerHTML = status.panels.map(panel => panel.html).join(\"\");\n\n    this.createPanels();\n\n    // Reset panel index\n    panelManager.originalPanels().forEach((panel, idx) => {\n      panel.setIndex(panels[idx].index);\n    });\n\n    this.currentPanel = panelManager.get(status.index)\n      || panelManager.get(defaultIndex)\n      || panelManager.firstPanel();\n\n    this.resize();\n\n    this.axes.setTo({ flick: status.position }, 0);\n    this.moveCamera(status.position);\n  }\n\n  public getCurrentPanel(): Panel | undefined {\n    return this.currentPanel;\n  }\n\n  public getCurrentIndex(): number {\n    const currentPanel = this.currentPanel;\n\n    return currentPanel\n      ? currentPanel.getIndex()\n      : -1;\n  }\n\n  public getNearestPanel(): Panel | undefined {\n    return this.nearestPanel;\n  }\n\n  // Get progress from nearest panel\n  public getCurrentProgress(): number {\n    const currentState = this.stateMachine.getState();\n    let nearestPanel = currentState.playing || currentState.holding\n      ? this.nearestPanel\n      : this.currentPanel;\n\n    const panelManager = this.panelManager;\n    if (!nearestPanel) {\n      // There're no panels\n      return NaN;\n    }\n    const {prev: prevRange, next: nextRange} = this.getScrollArea();\n    const cameraPosition = this.getCameraPosition();\n    const isOutOfBound = this.isOutOfBound();\n    let prevPanel = nearestPanel.prevSibling;\n    let nextPanel = nearestPanel.nextSibling;\n    let hangerPosition = this.getHangerPosition();\n    let nearestAnchorPos = nearestPanel.getAnchorPosition();\n\n    if (\n      isOutOfBound\n      && prevPanel\n      && nextPanel\n      && cameraPosition < nextRange\n      // On the basis of anchor, prevPanel is nearestPanel.\n      && (hangerPosition - prevPanel.getAnchorPosition() < nearestAnchorPos - hangerPosition)\n    ) {\n      nearestPanel = prevPanel;\n      nextPanel = nearestPanel.nextSibling;\n      prevPanel = nearestPanel.prevSibling;\n      nearestAnchorPos = nearestPanel.getAnchorPosition();\n    }\n    const nearestIndex = nearestPanel.getIndex() + (nearestPanel.getCloneIndex() + 1) * panelManager.getPanelCount();\n    const nearestSize = nearestPanel.getSize();\n\n    if (isOutOfBound) {\n      const relativeHangerPosition = this.getRelativeHangerPosition();\n\n      if (nearestAnchorPos > nextRange + relativeHangerPosition) {\n        // next bounce area: hangerPosition - relativeHangerPosition - nextRange\n        hangerPosition = nearestAnchorPos + hangerPosition - relativeHangerPosition - nextRange;\n      } else if (nearestAnchorPos < prevRange + relativeHangerPosition) {\n        // prev bounce area: hangerPosition - relativeHangerPosition - prevRange\n        hangerPosition = nearestAnchorPos + hangerPosition - relativeHangerPosition - prevRange;\n      }\n    }\n    const hangerIsNextToNearestPanel = hangerPosition >= nearestAnchorPos;\n    const gap = this.options.gap;\n\n    let basePosition = nearestAnchorPos;\n    let targetPosition = nearestAnchorPos;\n    if (hangerIsNextToNearestPanel) {\n      targetPosition = nextPanel\n        ? nextPanel.getAnchorPosition()\n        : nearestAnchorPos + nearestSize + gap;\n    } else {\n      basePosition = prevPanel\n        ? prevPanel.getAnchorPosition()\n        : basePosition = nearestAnchorPos - nearestSize - gap;\n    }\n\n    const progressBetween = (hangerPosition - basePosition) / (targetPosition - basePosition);\n    const startIndex = hangerIsNextToNearestPanel\n      ? nearestIndex\n      : prevPanel\n        ? prevPanel.getIndex()\n        : nearestIndex - 1;\n\n    return startIndex + progressBetween;\n  }\n\n  // Update axes flick position without triggering event\n  public updateAxesPosition(position: number) {\n    const axes = this.axes;\n    axes.off();\n    axes.setTo({\n      flick: position,\n    }, 0);\n    axes.on(this.axesHandlers);\n  }\n\n  public getSize(): number {\n    return this.state.size;\n  }\n\n  public getScrollArea(): { prev: number, next: number } {\n    return this.state.scrollArea;\n  }\n  public isOutOfBound(): boolean {\n    const state = this.state;\n    const options = this.options;\n    const scrollArea = state.scrollArea;\n\n    return !options.circular\n      && options.bound\n      && (state.position <= scrollArea.prev || state.position >= scrollArea.next);\n  }\n\n  public canSetBoundMode(): boolean {\n    const state = this.state;\n    const options = this.options;\n    const lastPanel = this.panelManager.lastPanel();\n    if (!lastPanel) {\n      return false;\n    }\n\n    const summedPanelSize = lastPanel.getPosition() + lastPanel.getSize();\n\n    return options.bound\n      && !options.circular\n      && summedPanelSize >= state.size;\n  }\n\n  public getScrollAreaSize(): number {\n    const scrollArea = this.state.scrollArea;\n\n    return scrollArea.next - scrollArea.prev;\n  }\n\n  public getRelativeHangerPosition(): number {\n    return this.state.relativeHangerPosition;\n  }\n\n  public getHangerPosition(): number {\n    return this.state.position + this.state.relativeHangerPosition;\n  }\n\n  public getCameraPosition(): number {\n    return this.state.position;\n  }\n\n  public setCurrentPanel(panel: Panel): void {\n    this.currentPanel = panel;\n  }\n\n  public setLastIndex(index: number): void {\n    const currentPanel = this.currentPanel;\n    const panelManager = this.panelManager;\n\n    panelManager.setLastIndex(index);\n    if (currentPanel && currentPanel.getIndex() > index) {\n      this.currentPanel = panelManager.lastPanel();\n    }\n\n    this.resize();\n  }\n\n  public connectAxesHandler(handlers: {[key: string]: (event: { [key: string]: any; }) => any}): void {\n    const axes = this.axes;\n\n    this.axesHandlers = handlers;\n    axes.on(handlers);\n  }\n\n  private build(): void {\n    this.applyCSSValue();\n    this.setMoveType();\n    this.setAxesInstance();\n    this.createPanels();\n    this.setDefaultPanel();\n    this.resize();\n    this.moveToDefaultPanel();\n  }\n\n  private applyCSSValue(): void {\n    const options = this.options;\n    const viewportElement = this.viewportElement;\n    const cameraElement = this.cameraElement;\n    const classPrefix = options.classPrefix;\n\n    // Set default css values for each element\n    viewportElement.className = `${classPrefix}-viewport`;\n    cameraElement.className = `${classPrefix}-camera`;\n\n    applyCSS(viewportElement, DEFAULT_VIEWPORT_CSS);\n    applyCSS(cameraElement, DEFAULT_CAMERA_CSS);\n\n    if (options.zIndex) {\n      viewportElement.style.zIndex = `${options.zIndex}`;\n    }\n    if (options.overflow) {\n      viewportElement.style.overflow = \"visible\";\n    }\n  }\n\n  private setMoveType(): void {\n    const moveType = this.options.moveType as MoveTypeObjectOption;\n\n    switch (moveType.type) {\n      case MOVE_TYPE.SNAP:\n        this.moveType = new Snap(moveType.count);\n        break;\n      case MOVE_TYPE.FREE_SCROLL:\n        this.moveType = new FreeScroll();\n        break;\n      default:\n        throw new Error(\"moveType is not correct!\");\n    }\n  }\n\n  private setAxesInstance(): void {\n    const state = this.state;\n    const options = this.options;\n\n    const scrollArea = state.scrollArea;\n    const horizontal = options.horizontal;\n\n    this.axes = new Axes({\n      flick: {\n        range: [scrollArea.prev, scrollArea.next],\n        circular: options.circular,\n        bounce: [0, 0], // will be updated in resize()\n      },\n    }, {\n      easing: options.panelEffect,\n      deceleration: options.deceleration,\n      interruptable: true,\n    });\n\n    this.panInput = new PanInput(this.viewportElement, {\n      inputType: options.inputType,\n      thresholdAngle: options.thresholdAngle,\n      scale: options.horizontal ? [-1, 0] : [0, -1],\n    });\n\n    this.axes.connect(horizontal ? [\"flick\", \"\"] : [\"\", \"flick\"], this.panInput);\n  }\n\n  private createPanels(): void {\n    // Panel elements were attached to camera element by Flicking class\n    const panelElements = this.cameraElement.children;\n\n    // Initialize panels\n    const panels = toArray(panelElements).map(\n      (el: HTMLElement, idx: number) => new Panel(el, idx, this),\n    );\n\n    if (panels.length > 0) {\n      this.panelManager.append(panels);\n    }\n  }\n\n  private setDefaultPanel(): void {\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const indexRange = this.panelManager.getRange();\n    const index = clamp(options.defaultIndex, indexRange.min, indexRange.max);\n\n    this.currentPanel = panelManager.get(index);\n  }\n\n  private clonePanels() {\n    const state = this.state;\n    const panelManager = this.panelManager;\n\n    const viewportSize = state.size;\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel() as Panel;\n\n    // There're no panels exist\n    if (!firstPanel) {\n      return;\n    }\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + this.options.gap;\n    const visibleAreaSize = viewportSize + firstPanel.getRelativeAnchorPosition();\n\n    // For each panels, clone itself while last panel's position + size is below viewport size\n    const panels = panelManager.originalPanels();\n\n    const cloneCount = Math.ceil(visibleAreaSize / sumOriginalPanelSize);\n    const prevCloneCount = panelManager.getCloneCount();\n\n    if (cloneCount > prevCloneCount) {\n      // should clone more\n      for (let cloneIndex = prevCloneCount; cloneIndex < cloneCount; cloneIndex++) {\n        const clones = panels.map(origPanel => {\n          const clonedPanel = origPanel.clone(cloneIndex);\n\n          this.cameraElement.appendChild(clonedPanel.getElement());\n          return clonedPanel;\n        });\n        panelManager.insertClones(cloneIndex, 0, clones);\n      }\n    } else if (cloneCount < prevCloneCount) {\n      // should remove some\n      panelManager.removeClonesAfter(cloneCount);\n    }\n  }\n\n  private moveToDefaultPanel(): void {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const options = this.options;\n    const indexRange = this.panelManager.getRange();\n\n    const defaultIndex = clamp(options.defaultIndex, indexRange.min, indexRange.max);\n    const defaultPanel = panelManager.get(defaultIndex);\n\n    let defaultPosition = 0;\n    if (defaultPanel) {\n      defaultPosition = defaultPanel.getAnchorPosition() - state.relativeHangerPosition;\n      defaultPosition = this.canSetBoundMode()\n        ? clamp(defaultPosition, state.scrollArea.prev, state.scrollArea.next)\n        : defaultPosition;\n    }\n\n    this.moveCamera(defaultPosition);\n    this.axes.setTo({ flick: defaultPosition }, 0);\n  }\n\n  private updateSize(): void {\n    const state = this.state;\n    const options = this.options;\n    const viewportElement = this.viewportElement;\n    const panels = this.panelManager.originalPanels();\n\n    if (!options.horizontal) {\n      // Don't preserve previous width for adaptive resizing\n      viewportElement.style.width = \"\";\n      viewportElement.style.minWidth = \"\";\n    }\n\n    const bbox = viewportElement.getBoundingClientRect();\n\n    // Update size & hanger position\n    state.size = options.horizontal\n      ? bbox.width\n      : bbox.height;\n\n    state.relativeHangerPosition = parseArithmeticExpression(options.hanger, state.size);\n    state.infiniteThreshold = parseArithmeticExpression(options.infiniteThreshold, state.size);\n\n    // Resize all panels\n    panels.forEach(panel => {\n      panel.resize();\n    });\n  }\n\n  private updateOriginalPanelPositions(): void {\n    const gap = this.options.gap;\n    const panelManager = this.panelManager;\n\n    const firstPanel = panelManager.firstPanel();\n    const panels = panelManager.originalPanels();\n\n    if (!firstPanel) {\n      return;\n    }\n\n    const currentPanel = this.currentPanel!;\n    const nearestPanel = this.nearestPanel;\n    const currentState = this.stateMachine.getState();\n    const scrollArea = this.state.scrollArea;\n\n    // Update panel position && fit to wrapper\n    let nextPanelPos = firstPanel.getPosition();\n    let maintainingPanel: Panel = firstPanel;\n    if (nearestPanel) {\n      // We should maintain nearestPanel's position\n      const looped = !isBetween(currentState.lastPosition + currentState.delta, scrollArea.prev, scrollArea.next);\n\n      maintainingPanel = looped\n        ? currentPanel\n        : nearestPanel;\n    } else if (firstPanel.getIndex() > 0) {\n      maintainingPanel = currentPanel;\n    }\n\n    const panelsBeforeMaintainPanel = panels.slice(0, maintainingPanel.getIndex() + (maintainingPanel.getCloneIndex() + 1) * panels.length);\n    const accumulatedSize = panelsBeforeMaintainPanel.reduce((total, panel) => {\n      return total + panel.getSize() + gap;\n    }, 0);\n\n    nextPanelPos = maintainingPanel.getPosition() - accumulatedSize;\n\n    panels.forEach(panel => {\n      const newPosition = nextPanelPos;\n      const currentPosition = panel.getPosition();\n      const panelSize = panel.getSize();\n\n      if (currentPosition !== newPosition) {\n        panel.setPosition(newPosition);\n      }\n      nextPanelPos += panelSize + gap;\n    });\n  }\n\n  private updateClonedPanelPositions(): void {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const clonedPanels = panelManager.clonedPanels()\n      .filter(panel => !!panel);\n\n    const scrollArea = state.scrollArea;\n\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel()!;\n\n    if (!firstPanel) {\n      return;\n    }\n\n    const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + options.gap;\n\n    // Locate all cloned panels linearly first\n    for (const panel of clonedPanels) {\n      if (!panel) {\n        continue;\n      }\n\n      const origPanel = panel.getOriginalPanel();\n      const cloneIndex = panel.getCloneIndex();\n      const cloneBasePos = sumOriginalPanelSize * (cloneIndex + 1);\n      const clonedPanelPos = cloneBasePos + origPanel.getPosition();\n\n      panel.setPosition(clonedPanelPos);\n    }\n\n    let lastReplacePosition = firstPanel.getPosition();\n    // reverse() pollutes original array, so copy it with concat()\n    for (const panel of clonedPanels.concat().reverse()) {\n      const panelSize = panel.getSize();\n      const replacePosition = lastReplacePosition - panelSize - options.gap;\n\n      if (replacePosition + panelSize <= scrollArea.prev) {\n        // Replace is not meaningful, as it won't be seen in current scroll area\n        break;\n      }\n\n      panel.setPosition(replacePosition);\n      lastReplacePosition = replacePosition;\n    }\n  }\n\n  private updateScrollArea(): void {\n    const state = this.state;\n    const panelManager = this.panelManager;\n    const options = this.options;\n    const axes = this.axes;\n\n    // Set viewport scrollable area\n    const firstPanel = panelManager.firstPanel();\n    const lastPanel = panelManager.lastPanel() as Panel;\n    const relativeHangerPosition = state.relativeHangerPosition;\n\n    if (!firstPanel) {\n      state.scrollArea = {\n        prev: 0,\n        next: 0,\n      };\n    } else if (this.canSetBoundMode()) {\n      state.scrollArea = {\n        prev: firstPanel.getPosition(),\n        next: lastPanel.getPosition() + lastPanel.getSize() - state.size,\n      };\n    } else if (options.circular) {\n      const sumOriginalPanelSize = lastPanel.getPosition() + lastPanel.getSize() - firstPanel.getPosition() + options.gap;\n\n      // Maximum scroll extends to first clone sequence's first panel\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - relativeHangerPosition,\n        next: sumOriginalPanelSize + firstPanel.getAnchorPosition() - relativeHangerPosition,\n      };\n    } else {\n      state.scrollArea = {\n        prev: firstPanel.getAnchorPosition() - relativeHangerPosition,\n        next: lastPanel.getAnchorPosition() - relativeHangerPosition,\n      };\n    }\n\n    const viewportSize = state.size;\n    const bounce = options.bounce;\n\n    let parsedBounce: number[] = bounce as [number, number];\n    if (isArray(bounce)) {\n      parsedBounce = (bounce as string[]).map(val => parseArithmeticExpression(val, viewportSize, DEFAULT_OPTIONS.bounce as number));\n    } else {\n      const parsedVal = parseArithmeticExpression(bounce as number | string, viewportSize, DEFAULT_OPTIONS.bounce as number);\n      parsedBounce = [parsedVal, parsedVal];\n    }\n\n    // Update axes range and bounce\n    const flick = axes.axis.flick;\n    flick.range = [state.scrollArea.prev, state.scrollArea.next];\n    flick.bounce = parsedBounce;\n  }\n\n  // Update camera position after resizing\n  private updateCameraPosition(): void {\n    const state = this.state;\n    const currentPanel = this.getCurrentPanel();\n    const currentState = this.stateMachine.getState();\n    const isFreeScroll = (this.options.moveType as MoveTypeObjectOption).type === \"freeScroll\";\n\n    if (currentState.holding || currentState.playing || isFreeScroll) {\n      return;\n    }\n\n    let newPosition = currentPanel\n      ? currentPanel.getAnchorPosition() - state.relativeHangerPosition\n      : this.getCameraPosition();\n\n    if (this.canSetBoundMode()) {\n      newPosition = clamp(newPosition, state.scrollArea.prev, state.scrollArea.next);\n    }\n\n    // Pause & resume axes to prevent axes's \"change\" event triggered\n    // This should be done before moveCamera, as moveCamera can trigger needPanel\n    this.updateAxesPosition(newPosition);\n\n    this.moveCamera(newPosition);\n  }\n\n  private checkNeedPanel(axesEvent?: any): void {\n    const state = this.state;\n    const options = this.options;\n    const panelManager = this.panelManager;\n    const currentPanel = this.currentPanel;\n    const nearestPanel = this.nearestPanel;\n    const currentState = this.stateMachine.getState();\n\n    if (!options.infinite) {\n      return;\n    }\n\n    const gap = options.gap;\n    const infiniteThreshold = state.infiniteThreshold;\n    const maxLastIndex = panelManager.getLastIndex();\n\n    if (maxLastIndex < 0) {\n      return;\n    }\n\n    if (!currentPanel || !nearestPanel) {\n      // There're no panels\n      this.triggerNeedPanel({\n        axesEvent,\n        siblingPanel: null,\n        direction: null,\n        indexRange: {\n          min: 0,\n          max: maxLastIndex,\n          length: maxLastIndex + 1,\n        },\n      });\n      return;\n    }\n\n    const originalNearestPosition = nearestPanel.getPosition();\n\n    // Check next direction\n    let checkingPanel: Panel | null = !currentState.holding && !currentState.playing\n      ? currentPanel\n      : nearestPanel;\n\n    while (checkingPanel) {\n      const currentIndex = checkingPanel.getIndex();\n      const nextSibling = checkingPanel.nextSibling;\n      let lastPanel = panelManager.lastPanel()!;\n      let atLastPanel = currentIndex === lastPanel.getIndex();\n      const nextIndex = !atLastPanel && nextSibling\n        ? nextSibling.getIndex()\n        : maxLastIndex + 1;\n      const currentNearestPosition = nearestPanel.getPosition();\n      const panelRight = checkingPanel.getPosition() + checkingPanel.getSize() - (currentNearestPosition - originalNearestPosition);\n      const cameraNext = state.position + state.size;\n\n      // There're empty panels between\n      const emptyPanelExistsBetween = (nextIndex - currentIndex > 1);\n      // Expected prev panel's left position is smaller than camera position\n      const overThreshold = panelRight + gap - infiniteThreshold <= cameraNext;\n\n      if (emptyPanelExistsBetween && overThreshold) {\n        this.triggerNeedPanel({\n          axesEvent,\n          siblingPanel: checkingPanel,\n          direction: DIRECTION.NEXT,\n          indexRange: {\n            min: currentIndex + 1,\n            max: nextIndex - 1,\n            length: nextIndex - currentIndex - 1,\n          },\n        });\n      }\n\n      // Trigger needPanel in circular & at max panel index\n      if (options.circular && currentIndex === maxLastIndex && overThreshold) {\n        const firstPanel = panelManager.firstPanel()!;\n        const firstIndex = firstPanel.getIndex();\n\n        if (firstIndex > 0) {\n          this.triggerNeedPanel({\n            axesEvent,\n            siblingPanel: checkingPanel,\n            direction: DIRECTION.NEXT,\n            indexRange: {\n              min: 0,\n              max: firstIndex - 1,\n              length: firstIndex,\n            },\n          });\n        }\n      }\n\n      // Check whether insertion happened\n      lastPanel = panelManager.lastPanel()!;\n      atLastPanel = currentIndex === lastPanel.getIndex();\n\n      if (atLastPanel || !overThreshold) {\n        break;\n      }\n\n      checkingPanel = checkingPanel.nextSibling;\n    }\n\n    // Check prev direction\n    checkingPanel = nearestPanel;\n    while (checkingPanel) {\n      const cameraPrev = state.position;\n      const checkingIndex = checkingPanel.getIndex();\n      const prevSibling = checkingPanel.prevSibling;\n      let firstPanel = panelManager.firstPanel()!;\n      let atFirstPanel = checkingIndex === firstPanel.getIndex();\n      const prevIndex = !atFirstPanel && prevSibling\n        ? prevSibling.getIndex()\n        : -1;\n      const currentNearestPosition = nearestPanel.getPosition();\n      const panelLeft = checkingPanel.getPosition() - (currentNearestPosition - originalNearestPosition);\n\n      // There're empty panels between\n      const emptyPanelExistsBetween = checkingIndex - prevIndex > 1;\n      // Expected prev panel's right position is smaller than camera position\n      const overThreshold = panelLeft - gap + infiniteThreshold >= cameraPrev;\n      if (emptyPanelExistsBetween && overThreshold) {\n        this.triggerNeedPanel({\n          axesEvent,\n          siblingPanel: checkingPanel,\n          direction: DIRECTION.PREV,\n          indexRange: {\n            min: prevIndex + 1,\n            max: checkingIndex - 1,\n            length: checkingIndex - prevIndex - 1,\n          },\n        });\n      }\n\n      // Trigger needPanel in circular & at panel 0\n      if (options.circular && checkingIndex === 0 && overThreshold) {\n        const lastPanel = panelManager.lastPanel()!;\n        const lastIndex = lastPanel.getIndex();\n\n        if (lastIndex < maxLastIndex) {\n          this.triggerNeedPanel({\n            axesEvent,\n            siblingPanel: checkingPanel,\n            direction: DIRECTION.PREV,\n            indexRange: {\n              min: lastIndex + 1,\n              max: maxLastIndex,\n              length: maxLastIndex - lastIndex,\n            },\n          });\n        }\n      }\n\n      // Check whether insertion happened\n      firstPanel = panelManager.firstPanel()!;\n      atFirstPanel = checkingIndex === firstPanel.getIndex();\n\n      // Looped in circular mode\n      if (atFirstPanel || !overThreshold) {\n        break;\n      }\n\n      checkingPanel = checkingPanel.prevSibling;\n    }\n  }\n\n  private triggerNeedPanel(params: {\n    axesEvent: any;\n    siblingPanel: Panel | null,\n    direction: FlickingEvent[\"direction\"];\n    indexRange: NeedPanelEvent[\"range\"];\n  }): void {\n    const { axesEvent, siblingPanel, direction, indexRange } = params;\n    const checkedIndexes = this.state.checkedIndexes;\n    const alreadyTriggered = checkedIndexes.some(([min, max]) => min === indexRange.min || max === indexRange.max);\n    const hasHandler = this.flicking.hasOn(EVENTS.NEED_PANEL);\n\n    if (alreadyTriggered || !hasHandler) {\n      return;\n    }\n\n    // Should done before triggering event, as we can directly add panels by event callback\n    checkedIndexes.push([indexRange.min, indexRange.max]);\n\n    const index = siblingPanel\n      ? siblingPanel.getIndex()\n      : 0;\n    const isTrusted = axesEvent\n      ? axesEvent.isTrusted\n      : false;\n\n    this.triggerEvent(\n      EVENTS.NEED_PANEL,\n      axesEvent,\n      isTrusted,\n      {\n        index,\n        panel: siblingPanel,\n        direction,\n        range: indexRange,\n      } as Partial<NeedPanelEvent>,\n    );\n  }\n}\n","import Component from \"@egjs/component\";\nimport Viewport from \"./components/Viewport\";\n\nimport { merge, getProgress, toArray, parseElement, isString } from \"./utils\";\nimport { DEFAULT_OPTIONS, EVENTS, DIRECTION, AXES_EVENTS, STATE_TYPE, DEFAULT_MOVE_TYPE_OPTIONS } from \"./consts\";\nimport { FlickingOptions, FlickingEvent, Direction, EventType, FlickingPanel, TriggerCallback, FlickingContext, FlickingStatus, Plugin, ElementLike } from \"./types\";\n\n/**\n * @memberof eg\n * @extends eg.Component\n * @support {\"ie\": \"10+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\" , \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @requires {@link https://github.com/naver/egjs-component|eg.Component}\n * @requires {@link https://github.com/naver/egjs-axes|eg.Axes}\n * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>\n */\nclass Flicking extends Component {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @example\n   * eg.Flicking.VERSION;  // ex) 3.0.0\n   * @memberof eg.Flicking\n   */\n  public static VERSION: string = \"#__VERSION__#\";\n  /**\n   * Direction constant - \"PREV\" or \"NEXT\"\n   * @ko 방향 상수 - \"PREV\" 또는 \"NEXT\"\n   * @example\n   * eg.Flicking.DIRECTION.PREV; // \"PREV\"\n   * eg.Flicking.DIRECTION.NEXT; // \"NEXT\"\n   */\n  public static DIRECTION: Direction = DIRECTION;\n\n  /**\n   * Event type object\n   * @ko 이벤트 이름 문자열들을 담은 객체\n   */\n  public static EVENTS: EventType = EVENTS;\n\n  public options: FlickingOptions;\n\n  private wrapper: HTMLElement;\n  private viewport: Viewport;\n  private eventContext: FlickingContext;\n  private plugins: Plugin[] = [];\n\n  /**\n   * @param element A base element for the eg.Flicking module. When specifying a value as a `string` type, you must specify a css selector string to select the element.<ko>eg.Flicking 모듈을 사용할 기준 요소. `string`타입으로 값 지정시 요소를 선택하기 위한 css 선택자 문자열을 지정해야 한다.</ko>\n   * @param options An option object of the eg.Flicking module<ko>eg.Flicking 모듈의 옵션 객체</ko>\n   * @param {string} [options.classPrefix=\"eg-flick\"] A prefix of class name will be added for the panels, viewport and camera.<ko>패널들과 뷰포트, 카메라에 추가될 클래스 이름의 접두사.</ko>\n   * @param {number} [options.deceleration=0.0075] Deceleration value for panel movement animation for animation triggered by manual user input. Higher value means shorter running time.<ko>사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다.</ko>\n   * @param {boolean} [options.horizontal=true] Direction of panel movement. (true: horizontal, false: vertical)<ko>패널 이동 방향. (true: 가로방향, false: 세로방향)</ko>\n   * @param {boolean} [options.circular=false] Enables circular mode, which connects first/last panel for continuous scrolling<ko>순환 모드를 활성화한다. 순환 모드에서는 양 끝의 패널이 서로 연결되어 끊김없는 스크롤이 가능하다.</ko>\n   * @param {boolean} [options.infinite=false] Enables infinite mode, which can automatically trigger needPanel until reaching last panel's index reaches lastIndex<ko>무한 모드를 활성화한다. 무한 모드에서는 needPanel 이벤트를 자동으로 트리거한다. 해당 동작은 마지막 패널의 인덱스가 lastIndex와 일치할때까지 일어난다.</ko>\n   * @param {number} [options.infiniteThreshold=0] A Threshold from viewport edge before triggering `needPanel` event in infinite mode.<ko>무한 모드에서 `needPanel`이벤트가 발생하기 위한 뷰포트 끝으로부터의 최대 거리.</ko>\n   * @param {number} [options.lastIndex=Infinity] Maximum panel index that Flicking can set. Flicking won't trigger `needPanel` when event's panel index is greater than it.<br>Also, if last panel's index reached given index, you can't add more panels.<ko>Flicking이 설정 가능한 패널의 최대 인덱스. `needPanel` 이벤트에 지정된 인덱스가 최대 패널의 개수보다 같거나 커야 하는 경우에 이벤트를 트리거하지 않게 한다.<br>또한, 마지막 패널의 인덱스가 주어진 인덱스와 동일할 경우, 새로운 패널을 더 이상 추가할 수 없다.</ko>\n   * @param {number} [options.threshold=40] Movement threshold to change panel(unit: pixel). It should be dragged above the threshold to change current panel.<ko>패널 변경을 위한 이동 임계값 (단위: 픽셀). 주어진 값 이상으로 스크롤해야만 패널 변경이 가능하다.</ko>\n   * @param {number} [options.duration=100] Duration of the panel movement animation.(unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @param {function} [options.panelEffect=x => 1 - Math.pow(1 - x, 3)] An easing function applied to the panel movement animation. Default value is `easeOutCubic`.<ko>패널 이동 애니메이션에 적용할 easing함수. 기본값은 `easeOutCubic`이다.</ko>\n   * @param {number} [options.defaultIndex=0] Index of panel to set as default when initializing. A zero-based integer.<ko>초기화시 지정할 디폴트 패널의 인덱스로, 0부터 시작하는 정수.</ko>\n   * @param {string[]} [options.inputType=[\"touch,\"mouse\"]] Types of input devices to enable.({@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption Reference})<ko>활성화할 입력 장치 종류. ({@link https://naver.github.io/egjs-axes/release/latest/doc/global.html#PanInputOption 참고})</ko>\n   * @param {number} [options.thresholdAngle=45] The threshold angle value(0 ~ 90).<br>If input angle from click/touched position is above or below this value in horizontal and vertical mode each, scrolling won't happen.<ko>스크롤 동작을 막기 위한 임계각(0 ~ 90).<br>클릭/터치한 지점으로부터 계산된 사용자 입력의 각도가 horizontal/vertical 모드에서 각각 크거나 작으면, 스크롤 동작이 이루어지지 않는다.</ko>\n   * @param {number|string|number[]|string[]} [options.bounce=[10,10]] The size value of the bounce area. Only can be enabled when `circular=false`.<br>You can set different bounce value for prev/next direction by using array.<br>`number` for px value, and `string` for px, and % value relative to viewport size.(ex - 0, \"10px\", \"20%\")<ko>바운스 영역의 크기값. `circular=false`인 경우에만 사용할 수 있다.<br>배열을 통해 prev/next 방향에 대해 서로 다른 바운스 값을 지정 가능하다.<br>`number`를 통해 px값을, `stirng`을 통해 px 혹은 뷰포트 크기 대비 %값을 사용할 수 있다.(ex - 0, \"10px\", \"20%\")</ko>\n   * @param {boolean} [options.autoResize=false] Whether resize() method should be called automatically after window resize event.<ko>window의 `resize` 이벤트 이후 자동으로 resize()메소드를 호출할지의 여부.</ko>\n   * @param {boolean} [options.adaptive=false] Whether the height(horizontal)/width(vertical) of the viewport element reflects the height/width value of the panel after completing the movement.<ko>목적 패널로 이동한 후 그 패널의 높이(horizontal)/너비(vertical)값을 뷰포트 요소의 높이/너비값에 반영할지 여부.</ko>\n   * @param {number} [options.zIndex=2000] z-index value for viewport element.<ko>뷰포트 엘리먼트의 z-index 값.</ko>\n   * @param {boolean} [options.bound=false] Prevent view from going out of first/last panel. Only can be enabled when `circular=false`.<ko>뷰가 첫번째와 마지막 패널 밖으로 나가는 것을 막아준다. `circular=false`인 경우에만 사용할 수 있다.</ko>\n   * @param {boolean} [options.overflow=false] Disables CSS property `overflow: hidden` in viewport if `true`.<ko>`true`로 설정시 뷰포트에 `overflow: hidden` 속성을 해제한다.</ko>\n   * @param {string} [options.hanger=\"50%\"] Reference position of hanger in viewport, which hangs panel anchors should be stopped at.<br>Should be provided in px or % value of viewport size.<br>You can combinate those values with plus/minus sign<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>뷰포트 내부의 행어의 위치. 패널의 앵커들이 뷰포트 내에서 멈추는 지점에 해당한다.<br>px값이나, 뷰포트의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {string} [options.anchor=\"50%\"] Reference position of anchor in panels, which can be hanged by viewport hanger.<br>Should be provided in px or % value of panel size.<br>You can combinate those values with plus/minus sign<br>ex) \"50\", \"100px\", \"0%\", \"25% + 100px\"<ko>패널 내부의 앵커의 위치. 뷰포트의 행어와 연계하여 패널이 화면 내에서 멈추는 지점을 설정할 수 있다.<br>px값이나, 패널의 크기 대비 %값을 사용할 수 있고, 이를 + 혹은 - 기호로 연계하여 사용할 수도 있다.<br>예) \"50\", \"100px\", \"0%\", \"25% + 100px\"</ko>\n   * @param {number} [options.gap=0] Space between each panels. Should be given in number.(px).<ko>패널간에 부여할 간격의 크기를 나타내는 숫자.(px)</ko>\n   * @param {eg.Flicking.MoveTypeOption} [options.moveType=\"snap\"] Movement style by user input.(ex: snap, freeScroll)<ko>사용자 입력에 의한 이동 방식.(ex: snap, freeScroll)</ko>\n   */\n  constructor(\n    element: string | HTMLElement,\n    options: Partial<FlickingOptions> = {},\n  ) {\n    super();\n\n    // Set flicking wrapper user provided\n    let wrapper: HTMLElement | null;\n    if (isString(element)) {\n      wrapper = document.querySelector(element);\n      if (!wrapper) {\n        throw new Error(\"Base element doesn't exist.\");\n      }\n    } else if (element.nodeName && element.nodeType === 1) {\n      wrapper = element;\n    } else {\n      throw new Error(\"Element should be provided in string or HTMLElement.\");\n    }\n\n    this.wrapper = wrapper;\n    // Override default options\n    this.options = merge({}, DEFAULT_OPTIONS, options) as FlickingOptions;\n    // Override moveType option\n    const currentOptions = this.options;\n    const moveType = currentOptions.moveType;\n\n    if (moveType in DEFAULT_MOVE_TYPE_OPTIONS) {\n      currentOptions.moveType = DEFAULT_MOVE_TYPE_OPTIONS[moveType as keyof typeof DEFAULT_MOVE_TYPE_OPTIONS];\n    }\n    this.build();\n  }\n\n  /**\n   * Move to the previous panel if it exists.\n   * @ko 이전 패널이 존재시 해당 패널로 이동한다.\n   * @param [duration=options.duration] Duration of the panel movement animation.(unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public prev(duration?: number): this {\n    const currentPanel = this.getCurrentPanel();\n    const currentState = this.viewport.stateMachine.getState();\n\n    if (!currentPanel || currentState.type !== STATE_TYPE.IDLE) {\n      return this;\n    }\n\n    const prevPanel = currentPanel.prev();\n    if (prevPanel) {\n      prevPanel.focus(duration);\n    }\n\n    return this;\n  }\n\n  /**\n   * Move to the next panel if it exists.\n   * @ko 다음 패널이 존재시 해당 패널로 이동한다.\n   * @param [duration=options.duration] Duration of the panel movement animation(unit: ms).<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public next(duration?: number): this {\n    const currentPanel = this.getCurrentPanel();\n    const currentState = this.viewport.stateMachine.getState();\n\n    if (!currentPanel || currentState.type !== STATE_TYPE.IDLE) {\n      return this;\n    }\n\n    const nextPanel = currentPanel.next();\n    if (nextPanel) {\n      nextPanel.focus(duration);\n    }\n\n    return this;\n  }\n\n  /**\n   * Move to the panel of given index.\n   * @ko 주어진 인덱스에 해당하는 패널로 이동한다.\n   * @param index The index number of the panel to move.<ko>이동할 패널의 인덱스 번호.</ko>\n   * @param duration [duration=options.duration] Duration of the panel movement.(unit: ms)<ko>패널 이동 애니메이션 진행 시간.(단위: ms)</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public moveTo(index: number, duration?: number): this {\n    const viewport = this.viewport;\n    const panel = viewport.panelManager.get(index);\n    const state = viewport.stateMachine.getState();\n\n    if (!panel || state.type !== STATE_TYPE.IDLE) {\n      return this;\n    }\n\n    const anchorPosition = panel.getAnchorPosition();\n    const hangerPosition = viewport.getHangerPosition();\n\n    let targetPanel = panel;\n    if (this.options.circular) {\n      const scrollAreaSize = viewport.getScrollAreaSize();\n      // Check all three possible locations, find the nearest position among them.\n      const possiblePositions = [\n        anchorPosition - scrollAreaSize,\n        anchorPosition,\n        anchorPosition + scrollAreaSize,\n      ];\n      const nearestPosition = possiblePositions.reduce((nearest, current) => {\n        return (Math.abs(current - hangerPosition) < Math.abs(nearest - hangerPosition))\n          ? current\n          : nearest;\n      }, Infinity) - panel.getRelativeAnchorPosition();\n\n      const identicals = panel.getIdenticalPanels();\n      const offset = nearestPosition - anchorPosition;\n      if (offset > 0) {\n        // First cloned panel is nearest\n        targetPanel = identicals[1];\n      } else if (offset < 0) {\n        // Last cloned panel is nearest\n        targetPanel = identicals[identicals.length - 1];\n      }\n\n      targetPanel = targetPanel.clone(targetPanel.getCloneIndex(), true);\n      targetPanel.setPosition(nearestPosition, true);\n    }\n    const currentIndex = this.getIndex();\n\n    if (hangerPosition === targetPanel.getAnchorPosition() && currentIndex === index) {\n      return this;\n    }\n\n    const eventType = panel.getIndex() === viewport.getCurrentIndex()\n      ? \"\"\n      : EVENTS.CHANGE;\n\n    viewport.moveTo(\n      targetPanel,\n      viewport.findEstimatedPosition(targetPanel),\n      eventType,\n      null,\n      duration,\n    );\n    return this;\n  }\n\n  /**\n   * Return index of the current panel. `-1` if no panel exists.\n   * @ko 현재 패널의 인덱스 번호를 반환한다. 패널이 하나도 없을 경우 `-1`을 반환한다.\n   * @return Current panel's index, zero-based integer.<ko>현재 패널의 인덱스 번호. 0부터 시작하는 정수.</ko>\n   */\n  public getIndex(): number {\n    return this.viewport.getCurrentIndex();\n  }\n\n  /**\n   * Return the wrapper element user provided in constructor.\n   * @ko 사용자가 생성자에서 제공한 래퍼 엘리먼트를 반환한다.\n   * @return Wrapper element user provided.<ko>사용자가 제공한 래퍼 엘리먼트.</ko>\n   */\n  public getElement(): HTMLElement {\n    return this.wrapper;\n  }\n\n  /**\n   * Return current panel. `null` if no panel exists.\n   * @ko 현재 패널을 반환한다. 패널이 하나도 없을 경우 `null`을 반환한다.\n   * @return Current panel.<ko>현재 패널.</ko>\n   */\n  public getCurrentPanel(): FlickingPanel | null {\n    const viewport = this.viewport;\n    const panel = viewport.getCurrentPanel();\n    return panel\n      ? panel\n      : null;\n  }\n\n  /**\n   * Return the panel of given index. `null` if it doesn't exists.\n   * @ko 주어진 인덱스에 해당하는 패널을 반환한다. 해당 패널이 존재하지 않을 시 `null`이다.\n   * @return Panel of given index.<ko>주어진 인덱스에 해당하는 패널.</ko>\n   */\n  public getPanel(index: number): FlickingPanel | null {\n    const viewport = this.viewport;\n    const panel = viewport.panelManager.get(index);\n    return panel\n      ? panel\n      : null;\n  }\n\n  /**\n   * Return all panels.\n   * @ko 모든 패널들을 반환한다.\n   * @param - Should include cloned panels or not.<ko>복사된 패널들을 포함할지의 여부.</ko>\n   * @return All panels.<ko>모든 패널들.</ko>\n   */\n  public getAllPanels(includeClone?: boolean): FlickingPanel[] {\n    const viewport = this.viewport;\n    const panelManager = viewport.panelManager;\n    const panels = includeClone\n      ? panelManager.allPanels()\n      : panelManager.originalPanels();\n\n    return panels\n      .filter(panel => !!panel);\n  }\n\n  /**\n   * Return the panels currently shown in viewport area.\n   * @ko 현재 뷰포트 영역에서 보여지고 있는 패널들을 반환한다.\n   * @return Panels currently shown in viewport area.<ko>현재 뷰포트 영역에 보여지는 패널들</ko>\n   */\n  public getVisiblePanels(): FlickingPanel[] {\n    return this.getAllPanels(true).filter(panel => {\n      const outsetProgress = panel.getOutsetProgress();\n\n      return outsetProgress > -1 && outsetProgress < 1;\n    });\n  }\n\n  /**\n   * Return length of original panels.\n   * @ko 원본 패널의 개수를 반환한다.\n   * @return Length of original panels.<ko>원본 패널의 개수</ko>\n   */\n  public getPanelCount(): number {\n    return this.viewport.panelManager.getPanelCount();\n  }\n\n  /**\n   * Set last panel index for `infinite' mode.<br>[needPanel]{@link eg.Flicking#events:needPanel} won't be triggered anymore when last panel's index reaches it.<br>Also, you can't add more panels after it.\n   * @ko `infinite` 모드에서 적용되는 패널의 최대 인덱스를 설정한다.<br>마지막 패널의 인덱스가 설정한 값에 도달할 경우 더 이상 [needPanel]{@link eg.Flicking#events:needPanel} 이벤트가 발생되지 않는다.<br>또한, 설정한 인덱스 이후로 새로운 패널을 추가할 수 없다.\n   * @param - Last panel index.\n   * @see {@link eg.Flicking.FlickingOptions}\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public setLastIndex(index: number): this {\n    this.viewport.setLastIndex(index);\n\n    return this;\n  }\n\n  /**\n   * Return panel movement animation.\n   * @ko 현재 패널 이동 애니메이션이 진행 중인지를 반환한다.\n   * @return Is animating or not.<ko>애니메이션 진행 여부.</ko>\n   */\n  public isPlaying(): boolean {\n    return this.viewport.stateMachine.getState().playing;\n  }\n\n  /**\n   * Unblock input devices.\n   * @ko 막았던 입력 장치로부터의 입력을 푼다.\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public enableInput(): this {\n    this.viewport.enable();\n\n    return this;\n  }\n\n  /**\n   * Block input devices.\n   * @ko 입력 장치로부터의 입력을 막는다.\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public disableInput(): this {\n    this.viewport.disable();\n\n    return this;\n  }\n\n  /**\n   * Get current flicking status. You can restore current state by giving returned value to [setStatus()]{@link eg.Flicking#setStatus}.\n   * @ko 현재 상태 값을 반환한다. 반환받은 값을 [setStatus()]{@link eg.Flicking#setStatus} 메소드의 인자로 지정하면 현재 상태를 복원할 수 있다.\n   * @return An object with current status value information.<ko>현재 상태값 정보를 가진 객체.</ko>\n   */\n  public getStatus(): FlickingStatus {\n    const viewport = this.viewport;\n\n    const panels = viewport.panelManager.originalPanels()\n      .filter(panel => !!panel)\n      .map(panel => {\n        return {\n          html: panel.getElement().outerHTML,\n          index: panel.getIndex(),\n        };\n      });\n\n    return {\n      index: viewport.getCurrentIndex(),\n      panels,\n      position: viewport.getCameraPosition(),\n    };\n  }\n\n  /**\n   * Restore to the state of the `status`.\n   * @ko `status`의 상태로 복원한다.\n   * @param status Status value to be restored. You can specify the return value of the [getStatus()]{@link eg.Flicking#getStatus} method.<ko>복원할 상태 값. [getStatus()]{@link eg.Flicking#getStatus}메서드의 반환값을 지정하면 된다.</ko>\n   */\n  public setStatus(status: FlickingStatus): void {\n    this.viewport.restore(status);\n  }\n\n  /**\n   * Add plugins that can have different effects on Flicking.\n   * @ko 플리킹에 다양한 효과를 부여할 수 있는 플러그인을 추가한다.\n   * @param - The plugin(s) to add.<ko>추가할 플러그인(들).</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public addPlugins(plugins: Plugin | Plugin[]) {\n    const newPlugins = ([] as Plugin[]).concat(plugins);\n\n    newPlugins.forEach(plugin => {\n      plugin.init(this);\n    });\n\n    this.plugins = this.plugins.concat(newPlugins);\n    return this;\n  }\n  /**\n   * Remove plugins from Flicking.\n   * @ko 플리킹으로부터 플러그인들을 제거한다.\n   * @param - The plugin(s) to remove.<ko>제거 플러그인(들).</ko>\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public removePlugins(plugins: Plugin | Plugin[]) {\n    const currentPlugins = this.plugins;\n    const removedPlugins = ([] as Plugin[]).concat(plugins);\n\n    removedPlugins.forEach(plugin => {\n      const index = currentPlugins.indexOf(plugin);\n\n      if (index > -1) {\n        currentPlugins.splice(index, 1);\n      }\n\n      plugin.destroy(this);\n    });\n    return this;\n  }\n\n  /**\n   * Return the reference element and all its children to the state they were in before the instance was created. Remove all attached event handlers. Specify `null` for all attributes of the instance (including inherited attributes).\n   * @ko 기준 요소와 그 하위 패널들을 인스턴스 생성전의 상태로 되돌린다. 부착된 모든 이벤트 핸들러를 탈거한다. 인스턴스의 모든 속성(상속받은 속성포함)에 `null`을 지정한다.\n   * @example\n   * const flick = new eg.Flicking(\"#flick\");\n   * flick.destroy();\n   * console.log(flick.moveTo); // null\n   */\n  public destroy(): void {\n    this.off();\n\n    this.viewport.destroy();\n\n    this.plugins.forEach(plugin => {\n      plugin.destroy(this);\n    });\n\n    // release resources\n    for (const x in this) {\n      (this as any)[x] = null;\n    }\n  }\n\n  /**\n   * Update panels to current state.\n   * @ko 패널들을 현재 상태에 맞춰 갱신한다.\n   * @return {eg.Flicking} The instance itself.<ko>인스턴스 자기 자신.</ko>\n   */\n  public resize(): this {\n    const viewport = this.viewport;\n\n    viewport.panelManager.allPanels()\n      .forEach(panel => panel.unCacheBbox());\n    viewport.resize();\n\n    return this;\n  }\n\n  /**\n   * Add new panels at the beginning of panels.\n   * @ko 제일 앞에 새로운 패널을 추가한다.\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\n   * @return Array of appended panels.<ko>추가된 패널들의 배열</ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.replace(3, document.createElement(\"div\")); // Add new panel at index 3\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\"); // Prepended at index 2\n   * flicking.prepend([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]); // Prepended at index 0, 1\n   * flicking.prepend(\"\\<div\\>Panel\\</div\\>\"); // Prepended at index 0, pushing every panels behind it.\n   */\n  public prepend(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n    const parsedElements = parseElement(element);\n\n    const insertingIndex = Math.max(viewport.panelManager.getRange().min - parsedElements.length, 0);\n    return viewport.insert(insertingIndex, parsedElements);\n  }\n\n  /**\n   * Add new panels at the end of panels.\n   * @ko 제일 끝에 새로운 패널을 추가한다.\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\n   * @return Array of appended panels.<ko>추가된 패널들의 배열</ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   * flicking.append(document.createElement(\"div\")); // Appended at index 0\n   * flicking.append(\"\\<div\\>Panel\\</div\\>\"); // Appended at index 1\n   * flicking.append([\"\\<div\\>Panel\\</div\\>\", document.createElement(\"div\")]); // Appended at index 2, 3\n   * // Even this is possible\n   * flicking.append(\"\\<div\\>Panel 1\\</div\\>\\<div\\>Panel 2\\</div\\>\"); // Appended at index 4, 5\n   */\n  public append(element: ElementLike | ElementLike[]): FlickingPanel[] {\n    const viewport = this.viewport;\n\n    return viewport.insert(viewport.panelManager.getRange().max + 1, element);\n  }\n\n  /**\n   * Replace existing panels with new panels from given index. If target index is empty, add new panel at target index.\n   * @ko 주어진 인덱스로부터의 패널들을 새로운 패널들로 교체한다. 인덱스에 해당하는 자리가 비어있다면, 새로운 패널을 해당 자리에 집어넣는다.\n   * @param index - Start index to replace new panels.<ko>새로운 패널들로 교체할 시작 인덱스</ko>\n   * @param element - Either HTMLElement, HTML string, or array of them.<br>It can be also HTML string of multiple elements with same depth.<ko>HTMLElement 혹은 HTML 문자열, 혹은 그것들의 배열도 가능하다.<br>또한, 같은 depth의 여러 개의 엘리먼트에 해당하는 HTML 문자열도 가능하다.</ko>\n   * @return Array of created panels by replace.<ko>교체되어 새롭게 추가된 패널들의 배열</ko>\n   * @example\n   * // Suppose there were no panels at initialization\n   * const flicking = new eg.Flicking(\"#flick\");\n   *\n   * // This will add new panel at index 3,\n   * // Index 0, 1, 2 is empty at this moment.\n   * // [empty, empty, empty, PANEL]\n   * flicking.replace(3, document.createElement(\"div\"));\n   *\n   * // As index 2 was empty, this will also add new panel at index 2.\n   * // [empty, empty, PANEL, PANEL]\n   * flicking.replace(2, \"\\<div\\>Panel\\</div\\>\");\n   *\n   * // Index 3 was not empty, so it will replace previous one.\n   * // It will also add new panels at index 4 and 5.\n   * // before - [empty, empty, PANEL, PANEL]\n   * // after - [empty, empty, PANEL, NEW_PANEL, NEW_PANEL, NEW_PANEL]\n   * flicking.replace(3, [\"\\<div\\>Panel\\</div\\>\", \"\\<div\\>Panel\\</div\\>\", \"\\<div\\>Panel\\</div\\>\"])\n   */\n  public replace(index: number, element: ElementLike | ElementLike[]): FlickingPanel[] {\n    return this.viewport.replace(index, element);\n  }\n\n  /**\n   * Remove panel at target index. This will decrease index of panels behind it.\n   * @ko `index`에 해당하는 자리의 패널을 제거한다. 수행시 `index` 이후의 패널들의 인덱스가 감소된다.\n   * @param index - Index of panel to remove.<ko>제거할 패널의 인덱스</ko>\n   * @param {number} [deleteCount=1] - Number of panels to remove from index.<ko>`index` 이후로 제거할 패널의 개수.</ko>\n   * @return Array of removed panels<ko>제거된 패널들의 배열</ko>\n   */\n  public remove(index: number, deleteCount: number = 1): FlickingPanel[] {\n    return this.viewport.remove(index, deleteCount);\n  }\n\n  private build(): void {\n    this.initViewport();\n    this.listenInput();\n    this.listenResize();\n  }\n\n  private initViewport(): void {\n    const wrapper = this.wrapper;\n    const options = this.options;\n    const cameraElement = document.createElement(\"div\");\n\n    // Make all panels to be a child of camera element\n    // wrapper <- viewport <- camera <- panels[1...n]\n    toArray(wrapper.children).forEach(child => {\n      cameraElement.appendChild(child);\n    });\n\n    // Clipping area for camera element\n    const viewportElement = document.createElement(\"div\");\n    viewportElement.appendChild(cameraElement);\n\n    // Add viewport element to wrapper\n    wrapper.appendChild(viewportElement);\n\n    // Make viewport instance with panel container element\n    this.viewport = new Viewport(this, viewportElement, cameraElement, options, this.triggerEvent);\n  }\n\n  private listenInput(): void {\n    const flicking = this;\n    const viewport = flicking.viewport;\n    const stateMachine = viewport.stateMachine;\n\n    // Set event context\n    flicking.eventContext = {\n      flicking,\n      viewport: flicking.viewport,\n      transitTo: stateMachine.transitTo,\n      triggerEvent: flicking.triggerEvent,\n      moveCamera: flicking.moveCamera,\n      stopCamera: viewport.stopCamera,\n    };\n\n    const handlers = {};\n    for (const key in AXES_EVENTS) {\n      const eventType = AXES_EVENTS[key];\n\n      handlers[eventType] = (e: any) => stateMachine.fire(eventType, e, flicking.eventContext);\n    }\n\n    // Connect Axes instance with PanInput\n    flicking.viewport.connectAxesHandler(handlers);\n  }\n\n  private listenResize(): void {\n    if (this.options.autoResize) {\n      window.addEventListener(\"resize\", () => {\n        this.resize();\n      });\n    }\n  }\n\n  private triggerEvent = <T extends FlickingEvent>(\n    eventName: string,\n    axesEvent: any,\n    isTrusted: boolean,\n    params: Partial<T> = {},\n  ): TriggerCallback => {\n    const viewport = this.viewport;\n\n    let canceled: boolean = true;\n\n    // Ignore events before viewport is initialized\n    if (viewport) {\n      const state = viewport.stateMachine.getState();\n      const { prev, next } = viewport.getScrollArea();\n      const pos = viewport.getCameraPosition();\n      let progress = getProgress(pos, [prev, prev, next]);\n\n      if (this.options.circular) {\n        progress %= 1;\n      }\n      canceled = !super.trigger(eventName, merge({\n        type: eventName,\n        index: this.getIndex(),\n        panel: this.getCurrentPanel(),\n        direction: state.direction,\n        holding: state.holding,\n        progress,\n        axesEvent,\n        isTrusted,\n      }, params));\n    }\n\n    return {\n      onSuccess(callback: () => void): TriggerCallback {\n        if (!canceled) {\n          callback();\n        }\n        return this;\n      },\n      onStopped(callback: () => void): TriggerCallback {\n        if (canceled) {\n          callback();\n        }\n        return this;\n      },\n    } as TriggerCallback;\n  }\n\n  // Return result of \"move\" event triggered\n  private moveCamera = (axesEvent: any): TriggerCallback => {\n    const viewport = this.viewport;\n    const state = viewport.stateMachine.getState();\n    const options = this.options;\n\n    const pos = axesEvent.pos.flick;\n    const previousPosition = viewport.getCameraPosition();\n\n    if (axesEvent.isTrusted && state.holding) {\n      const inputOffset = options.horizontal\n        ? axesEvent.inputEvent.offsetX\n        : axesEvent.inputEvent.offsetY;\n\n      const isNextDirection = inputOffset < 0;\n\n      let cameraChange = pos - previousPosition;\n      const looped = isNextDirection === (pos < previousPosition);\n      if (options.circular && looped) {\n        // Reached at max/min range of axes\n        const scrollAreaSize = viewport.getScrollAreaSize();\n        cameraChange = (cameraChange > 0 ? -1 : 1) * (scrollAreaSize - Math.abs(cameraChange));\n      }\n\n      const currentDirection = cameraChange === 0\n        ? state.direction\n        : cameraChange > 0\n          ? DIRECTION.NEXT\n          : DIRECTION.PREV;\n\n      state.direction = currentDirection;\n    }\n    state.delta += axesEvent.delta.flick;\n\n    viewport.moveCamera(pos, axesEvent);\n    return this.triggerEvent(EVENTS.MOVE, axesEvent, axesEvent.isTrusted)\n      .onStopped(() => {\n        // Undo camera movement\n        viewport.moveCamera(previousPosition, axesEvent);\n      });\n  }\n}\n\nexport default Flicking;\n"],"names":["target","_i","srcs","forEach","source","Object","keys","key","value","element","Array","isArray","elements","el","isString","tempDiv","document","createElement","innerHTML","push","toArray","children","checkTranslateSupport","transforms","webkitTransform","msTransform","MozTransform","OTransform","transform","supportedStyle","documentElement","style","transformName","prefixedTransform","Error","insertBefore","styleVal","window","getComputedStyle","getPropertyValue","parentElement","removeChild","transformInfo","name","has3d","length","className","classList","add","indexOf","replace","cssObj","property","val","min","max","Math","iterable","slice","call","arr","constructor","cssValue","base","defaultVal","defaultValue","cssRegex","clamp","idx","calculatedValue","matchResult","exec","sign","unit","parsedValue","parseFloat","pos","range","center","callback","i","counterArray","indexed","size","offset","MOVE_TYPE","SNAP","FREE_SCROLL","DEFAULT_MOVE_TYPE_OPTIONS","snap","type","count","freeScroll","DEFAULT_OPTIONS","classPrefix","deceleration","horizontal","circular","infinite","infiniteThreshold","lastIndex","Infinity","threshold","duration","panelEffect","x","pow","defaultIndex","inputType","thresholdAngle","bounce","autoResize","adaptive","zIndex","bound","overflow","hanger","anchor","gap","moveType","DEFAULT_VIEWPORT_CSS","position","width","height","DEFAULT_CAMERA_CSS","willChange","DEFAULT_PANEL_CSS","EVENTS","HOLD_START","HOLD_END","MOVE_START","MOVE","MOVE_END","CHANGE","RESTORE","SELECT","NEED_PANEL","AXES_EVENTS","HOLD","RELEASE","ANIMATION_END","FINISH","STATE_TYPE","IDLE","HOLDING","DRAGGING","ANIMATING","DISABLED","DIRECTION","PREV","NEXT","TRANSFORM","index","viewport","prevSibling","nextSibling","state","relativeAnchorPosition","clonedPanels","isClone","cloneIndex","originalStyle","getAttribute","cachedBbox","options","addClass","applyCSS","bbox","getBbox","parseArithmeticExpression","panel","resize","panelCount","panelManager","getPanelCount","scrollAreaSize","getScrollAreaSize","relativeIndex","floor","getPosition","getIndex","progress","getCurrentProgress","outsetRange","getSize","getRelativeHangerPosition","getRelativeAnchorPosition","relativePanelPosition","getCameraPosition","outsetProgress","getProgress","panelSize","rightRelativePanelPosition","visibleSize","visibleRatio","currentPanel","getCurrentPanel","hangerPosition","getHangerPosition","anchorPosition","getAnchorPosition","currentPosition","eventType","moveTo","findEstimatedPosition","updateFunction","getIdenticalPanels","eachPanel","getElement","unCacheBbox","currentIndex","prevPanelIndex","prevPanelPosition","prevPanelSize","hasEmptyPanelBetween","notYetMinPanel","newPosition","prevPanel","clone","getCloneIndex","setPosition","getLastIndex","nextPanelIndex","nextPanelPosition","notYetMaxPanel","nextPanel","parsedElements","parseElement","firstPanel","targetIndex","insert","remove","setAttribute","removeAttribute","getBoundingClientRect","original","getClonedPanels","virtual","elementStyle","left","top","cloneElement","cloneNode","clonedPanel","Panel","clonedState","parentNode","removeClonedPanelsAfter","start","removingPanels","splice","removeElement","cameraElement","panels","clones","reduce","allClones","lastPanel","firstRemovedPanel","filter","possibleLastPanel","newPanels","_a","isCircular","findFirstPanelFrom","siblingElement","fragment","createDocumentFragment","appendChild","pushedIndex","panelsAfterIndex","emptyPanelCount","findIndex","removedPanels","Boolean","newLastIndex","concat","reverse","setIndex","addNewClones","updateIndex","replacedPanels","wasNonEmptyCount","deleteCount","deletedPanels","cloneSet","reversedPanels","nonEmptyIndexFromLast","allPanels","allPanelsCount","newClones_1","insertTarget_1","allPanels_1","panelElement","contains","originalPanels","cloneCount","getCloneCount","lastPanelClones","nextSiblingClones","cloneNextSibling","lastPanelSibling","cloneSiblingElement","nextElementSibling","newClones","map","this_1","insertClones","counter","insertingIndex","prevState","delta","direction","targetPanel","lastPosition","nextState","e","context","tslib_1","_this","flicking","triggerEvent","transitTo","onSuccess","onStopped","onChange","State","inputEvent","offsetX","offsetY","flick","setTo","releaseEvent","clickedElement","srcEvent","clickedPanel","findPanelOf","cameraPosition","clickedPanelPosition","moveCamera","stopCamera","isFreeScroll","is","velocity","velocityX","velocityY","inputDelta","deltaX","deltaY","isNextDirection","abs","swipeDistance","swipeAngle","atan","PI","belowAngleThreshold","overThreshold","destPos","nearestPanel","getNearestPanel","stop","moveTypeContext","axesEvent","destInfo","findTargetPanel","findRestorePanel","scrollArea","getScrollArea","loopCount","prev","originalTargetPosition","newCloneIndex","circulate","newTargetPosition","newTargetPanel","setCurrentPanel","isTrusted","updateAdaptiveSize","updateAxesPosition","IdleState","nextStateType","currentState","HoldingState","DraggingState","AnimatingState","DisabledState","onExit","onEnter","onHold","onRelease","onAnimationEnd","onFinish","ctx","findRestorePanelInCircularMode","halfGap","minimumDistanceToChange","originalPanel","getOriginalPanel","firstClonedPanel","lapped","_super","snapCount","eventDelta","calcBrinkOfChange","shouldMoveWhenBounceIs0","canSetBoundMode","shouldMoveToAdjacent","isOutOfBound","findSnappedPanel","findAdjacentPanel","estimatedHangerPos","panelToMove","cycleIndex","passedPanelCount","siblingPanel","panelIndex","siblingIndex","panelPosition","panelNextPosition","panelPrevPosition","originalPosition","defaultDuration","getCurrentIndex","get","basePanel","basePosition","adjacentPanel","targetRelativeAnchorPosition","estimatedPanelPosition","estimatedPosition","MoveType","next","findNearestPanelAt","stateMachine","getState","currentPanelPosition","lastHangerPosition","Snap","viewportElement","relativeHangerPosition","translate","checkedIndexes","StateMachine","PanelManager","build","eventResult","axes","findNearestPanel","originalNearestPosition","checkNeedPanel","modifiedNearestPosition","moveVector","moveCoord","coord","round","join","updateSize","updateOriginalPanelPositions","updateScrollArea","clonePanels","updateClonedPanelPositions","chainAllPanels","updateCameraPosition","minimumDistance","prevPosition","nextPosition","distance","isBetween","minimumAnchorDistance","anchorDistance","nearest","shortestDistance","identicals","identical","panInput","enable","disable","indexes","wasEmpty","newCurrentIndex","getRange","sizeToApply","panelBbox","maximumPanelSize","maximum","viewportStyle","minHeight","minWidth","wrapper","destroy","status","clear","html","createPanels","playing","holding","NaN","prevRange","nextRange","nearestAnchorPos","nearestIndex","nearestSize","hangerIsNextToNearestPanel","targetPosition","progressBetween","startIndex","off","on","axesHandlers","summedPanelSize","setLastIndex","handlers","applyCSSValue","setMoveType","setAxesInstance","setDefaultPanel","moveToDefaultPanel","FreeScroll","Axes","easing","interruptable","PanInput","scale","connect","panelElements","append","indexRange","viewportSize","sumOriginalPanelSize","visibleAreaSize","ceil","prevCloneCount","origPanel","removeClonesAfter","defaultPanel","defaultPosition","nextPanelPos","maintainingPanel","looped","panelsBeforeMaintainPanel","accumulatedSize","total","clonedPanels_1","cloneBasePos","clonedPanelPos","lastReplacePosition","_b","replacePosition","parsedBounce","parsedVal","axis","maxLastIndex","triggerNeedPanel","checkingPanel","atLastPanel","nextIndex","currentNearestPosition","panelRight","cameraNext","emptyPanelExistsBetween","firstIndex","cameraPrev","checkingIndex","atFirstPanel","prevIndex","panelLeft","params","alreadyTriggered","some","hasHandler","hasOn","eventName","canceled","trigger","merge","previousPosition","inputOffset","cameraChange","currentDirection","querySelector","nodeName","nodeType","currentOptions","focus","possiblePositions","nearestPosition","current","includeClone","getAllPanels","getOutsetProgress","outerHTML","restore","plugins","newPlugins","plugin","init","currentPlugins","removedPlugins","initViewport","listenInput","listenResize","child","Viewport","eventContext","fire","connectAxesHandler","addEventListener","Flicking","Component"],"mappings":"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"}